#!/usr/bin/env python3

# Requires the environment variable PYTHONSTARTUP to be set to the path of this
# file.  This file does a few things for my interactive shell to facilitate
# common tasks

# Import a few modules so that I don't have to do it manually
import sys

# For factors?
sys.path.append('/home/phc001/fs1/libexec/philutils/')
sys.path.append('/home/phc001/fs1/bin')
import os
import subprocess
import math as m
imports = "sys, os, subprocess"
try: import psutil
except: imports += ", not(psutil)"
else: imports += ", psutil"

try: import factors as f
except: imports += ", not(factors)"
else: imports += ", factors as f"

try: import requests as r
except: imports += ", not(requests)"
else: imports += ", requests as r"

print(f"iPython {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.minor} -- {sys.executable}")
print(f"~/.pyrc: Imported {imports}")
# Set a nicer prompt with colors from the Python logo and a snake emoji
__ps1_color = '255;212;59'
__ps2_color = '95;135;215'  # This is color 81 which looks best
sys.ps1 = f"\x01\033[38;2;{__ps1_color}m\033[48;2;{__ps1_color}m\x02" \
          + "\U0001f40d\x01\033[49m\x02\ue0b0\x01\033[0m\x02 "
sys.ps2 = f"\001\033[38;5;81m\002\u2588\u2588\ue0b0\001\033[0m\002 "
del __ps1_color, __ps2_color

# A quick function to open the code where any python object is defined (function,
# module, class etc.
class p:
    @staticmethod
    def view_code(obj):
        if hasattr(obj, "__code__"):
            print(f"Object {obj}'s code is in {obj.__code__.co_filename} at line {obj.__code__.co_firstlineno}")
            vi_args = [obj.__code__.co_filename, f'+{obj.__code__.co_firstlineno}']
        elif hasattr(obj, "__file__"):
            print(f"Object {obj} has does not have a __code__ attribute but does have a __file__ attribute: {obj.__file__}")
            vi_args = [obj.__file__]
        else:
            print(f"Object {obj} does not have a __code__ or a __file__ attribute, we're out of luck")
            return
        subprocess.run(['vim', *vi_args])

    @staticmethod
    def run(cmd, type=lambda x:x, dir=None):
        res = subprocess.run(cmd, cwd=dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        if res.returncode != 0:
            print(f"Command '{cmd}' failed: {res.stderr}")
        l = list(map(type, res.stdout.strip().splitlines()))
        if len(l) == 1:
            return l[0]
        elif len(l) == 0:
            return None
        else:
            return l

    @staticmethod
    def read(file):
        if not os.path.isfile(file):
            print(f"read('{file}'): File does not exist")
            return
        with open(file) as f:
            return f.read()

    # And a few python functions that I find useful
    @staticmethod
    def get_process_memory_usage():
        import sys
        import os
        process = psutil.Process(os.getpid())
        return process.memory_info().rss
