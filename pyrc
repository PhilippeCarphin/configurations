#!/usr/bin/env python3

# Requires the environment variable PYTHONSTARTUP to be set to the path of this
# file.  This file does a few things for my interactive shell to facilitate
# common tasks

# Import a few modules so that I don't have to do it manually
import sys

# For factors?
sys.path.append('/home/phc001/fs1/libexec/philutils/')
sys.path.append('/home/phc001/fs1/bin')
import os
import subprocess
import psutil
import math as m

from factors import *

print(f"~/.pyrc: Imported sys, os, subprocess, psutil, factors.*")

# Set a nicer prompt with colors from the Python logo and a snake emoji
__ps1_color = '255;212;59'
__ps2_color = '95;135;215'  # This is color 81 which looks best
sys.ps1 = f"\x01\033[38;2;{__ps1_color}m\033[48;2;{__ps1_color}m\x02" \
          + "\U0001f40d\x01\033[49m\x02\ue0b0\x01\033[0m\x02 "
sys.ps2 = f"\001\033[38;5;81m\002\u2588\u2588\ue0b0\001\033[0m\002 "
del __ps1_color, __ps2_color

# A quick function to open the code where any python object is defined (function,
# module, class etc.
def view_code(obj):
    if hasattr(obj, "__code__"):
        print(f"Object {obj}'s code is in {obj.__code__.co_filename} at line {obj.__code__.co_firstlineno}")
        vi_args = [obj.__code__.co_filename, f'+{obj.__code__.co_firstlineno}']
    elif hasattr(obj, "__file__"):
        print(f"Object {obj} has does not have a __code__ attribute but does have a __file__ attribute: {obj.__file__}")
        vi_args = [obj.__file__]
    else:
        print(f"Object {obj} does not have a __code__ or a __file__ attribute, we're out of luck")
        return
    subprocess.run(['vim', *vi_args])

def get_output(cmd, type=lambda x:x, dir=None):
    res = subprocess.run(cmd, cwd=dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
    if res.returncode != 0:
        print(f"Command '{cmd}' failed: {res.stderr}")
    l = list(map(type, res.stdout.strip().splitlines()))
    if len(l) == 1:
        return l[0]
    elif len(l) == 0:
        return None
    else:
        return l

def read(file):
    if not os.path.isfile(file):
        print(f"read('{file}'): File does not exist")
        return
    with open(file) as f:
        return f.read()

# And a few python functions that I find useful
def get_process_memory_usage():
    import sys
    import os
    process = psutil.Process(os.getpid())
    return process.memory_info().rss
