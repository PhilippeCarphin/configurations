#!/bin/bash

p.error(){
    printf "${FUNCNAME[1]}: \033[1;31mERROR\033[0m: $*\n" >&2
}

function p.profile.main(){
    export EDITOR=/usr/bin/vim
    export LOG_LEVEL=ERROR # For r.load
    export CMAKE_EXPORT_COMPILE_COMMANDS=TRUE
    export TZ=America/Toronto
    export LANG=en_US.UTF-8
    export SSM_DEV=/home/ords/cmdd/cmds/nil000/ssm
    export GITLAB_RUNNER_SCIENCE_ORDSOUMET_KEEP_FILES='yas'
    export GONOSUMDB=gitlab.science.gc.ca
    export PATH="$HOME/bin:$HOME/.local/bin${PATH:+:$PATH}:$HOME/tools/go/bin:${HOME}/tools/rust-1.75/bin:$HOME/tools/node-v16.13.1-linux-x64/bin"
    local p=http://webproxy.science.gc.ca:8888/
    export http_proxy=${p}
    export https_proxy=${p}
    export HTTP_PROXY=${p}
    export HTTPS_PROXY=${p}
    # export EDITOR=/usr/bin/vim
    configure_fs1_env
    configure_spack
    configure_vscode_server_environment
    if [[ "$-" == *i* ]] ; then
        p.profile.main_interactive
    fi
}

function p.profile.main_interactive(){
    export PYTHONSTARTUP=~/.pyrc
    export PACK_DIR=${HOME}/.profile.d/interactive/pack
    set_ls_colors_for_readline_and_ls

    source "$HOME/Repositories/github.com/philippecarphin/bash-powerline/powerline.sh"
    PROMPT_COMMAND="$PROMPT_COMMAND; history -a"
    source "$HOME/.git-completion.bash"
    source "$HOME/.ssh/ssh_functions.sh"
    source "$HOME/.philconfig/shell_lib/x.use"
    source "$HOME/.philconfig/shell_lib/functions.sh"
    source "$HOME/.philconfig/shell_lib/view-rev-file.sh"
    source "$HOME/Repositories/github.com/philippecarphin/env-diff/env-diff-cmd.bash"
    FZF_COMPLETION_OPT="--preview 'bat --color=always {}'"
    source ~/.fzf.bash
    _source_dir "$HOME/.bash_completion.d"

    alias ls='ls --color -h'
    alias grep='grep -n --color'
    alias tree='tree -C'
    alias rmb='rm -rf ../build/*'
    alias rg='rg --no-heading --color=auto'
    alias gdb='~phb001/.local_rhel-8-icelake-64/bin/gdb -q -tui'
    alias gdbserver='~phb001/.local_rhel-8-icelake-64/bin/gdbserver'
    alias diff='diff -u --color'
    alias :wqa='exit 0'
    alias :q='exit 0'
    alias :qa='exit 0'
    alias :wq='exit 0'
    alias :cq='exit 1'
    alias cd='gcps_wrap_command_colon_paths cd'
    complete -F _gcps_complete_cd cd
    alias git=git-enforce-rules-of-philippes
    complete -o default -o nospace -o filenames -F _DottableCompletion source .
    shopt -s direxpand # Merci Philippe Blain :D
    # Stolen from gil000: Processes Per User
    alias ppu='ps hax -o user | sort -n | uniq -c | sort -n'
    # Stolen from gil000: Running Processes Per User
    alias rppu='ps haxr -o user | sort -n | uniq -c | sort -n'
    check-alert-file ~sici000/alert
    check-alert-file ~/alert
    maybe_cd_to_pbs_o_workdir
    configure_history
    configure_vim
}

configure_fs1_env(){
    # See code of __load_completion from /usr/share/bash-completion/bash_completion ...
    # It searches an array of directories that starts out as
    # Since I don't define BASH_COMPLETION_USER_DIR and XDG_DATA_HOME
    # is also not defined, dirs=(${HOME}/.local/share/bash-completion/completions).
    # 1   dirs=(${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions)
    #     # Equivalently: dirs is defined following this logic:
    #     # if[[ -z ${BASH_COMPLETION_USER_DIR} ]] ; then
    #     #     dirs=(${BASH_COMPLETION_USER_DIR}/completions)
    #     # else
    #     #     if [[ -n ${XDG_DATA_HOME} ]] ; then
    #     #         dirs=(${XDG_DATA_HOME}/bash-completion/completions)
    #     #     else
    #     #         dirs=($HOME/.local/share/bash-completion/completions)
    #     #     fi
    #     # fi
    #
    #     # Add '$d/bash-completion/completions' for each dir in XDG_DATA_DIRS and /usr/local/share and /usr/share
    # 2   for dir in ${XDG_DATA_DIRS:-/usr/local/share:/usr/share};
    #         dirs+=($dir/bash-completion/completions);
    #     done
    #
    # So basically, the initialization at 1 adds
    #
    #       $HOME/.local/share/bash-completion/completions
    #
    # because BASH_COMPLETION_USER_DIR and XDG_DATA_HOME are unset.  Next, we
    # add
    #
    #       $dir/bash-completion/completions
    #
    # for d in $XDG_DATA_DIRS (colon separated list) therefore.
    #
    # To work with this system, completions should be stored in
    #
    #       <SOME_DIR>/bash-completion/completions
    #
    # and <SOME_DIR> should be added to XDG_DATA_DIRS.  In this case, I have
    # been putting completion scripts inside etc but looking at 2, it seems
    # like share would be more appropriate.
    #
    export STOW_DIR="$HOME/fs1"
    XDG_DATA_DIRS=${XDG_DATA_DIRS:+${XDG_DATA_DIRS}:}${STOW_DIR}/share:${STOW_DIR}/etc
    export PACKAGE_DIR="$STOW_DIR/Cellar"
    export LD_LIBRARY_PATH="${STOW_DIR}/lib:${STOW_DIR}/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}"
    export PATH=${STOW_DIR}/bin${PATH:+:${PATH}}
    _source_dir "$HOME/fs1/etc/bash_completion.d"
    _source_dir "$HOME/fs1/etc/profile.d"
}

maybe_cd_to_pbs_o_workdir(){
    if [[ "${PBS_ENVIRONMENT}" == PBS_INTERACTIVE ]] ; then
        printf "PBS_ENVIRONMENT detected, cd'ing to \$PBS_O_WORKDIR=${PBS_O_WORKDIR}\n" >&2
        if ! cd "${PBS_O_WORKDIR}" ; then
            p.error "Could not CD to '$PBS_O_WORKDIR', perhaps it is not on a network filesystem"
        fi
        echo "${PBS_JOBID}" > ~/.ssh/current_job
        echo "JOBID ${PBS_JOBID} written in ~/.ssh/current_job" >&2
    fi
}


function maybe-source(){
    if [ -f "${1}" ] ; then
        source "$1"
    fi
}

################################################################################
# Certain things about our environment setup don't jive well with vscode-server
# so we override them for that case.
# - TMPDIR: contains the PID of the process that loaded ordenv. Otherwise:
#   - parent : lauches a child
#   - child : has TMPDIR which contains PID of parent
#   - parent : detaches child and exits, causing r.cleanup_tmpdir to delete
#              TMPDIR
#   - child : has a TMPDIR which does not exist.
#
################################################################################
configure_vscode_server_environment(){
    # Dump environment to file at very beginning to see what the env looks
    # like when vscode server logs in.
    #
    # env -0 | sort -z | tr '\0' '\n' > ~/env_$(date +%Y-%m-%d_%H.%M.%S)
    #
    if [[ -v VSCODE_AGENT_FOLDER ]] ; then
        export GO111MODULES=off
        export TMPDIR=/tmp/$USER/vscode-server
        mkdir -p ${TMPDIR}
    fi

    # At work, the sshd config is has a slight problem.  The expected behavior
    # is that sshd creates /run/user/$(id -u) and sets XDG_RUNTIME_DIR to that
    # value.  The observed behavior is that it sets XDG_RUNTIME_DIR but does
    # not always create the directory.  Only sshd can create this directory, the
    # user cannot.  To mitigate this, I set it to something else.
    export XDG_RUNTIME_DIR=/tmp/$USER/xdg_runtime_dir
    mkdir -p ${XDG_RUNTIME_DIR}
}

configure_spack(){
    export SPACK_SKIP_MODULES=y
    if [[ -n "${SPACK_SKIP_MODULES}" ]] ; then echo "WARNING: SPACK_SKIP_MODULES is set" >&2 ; fi
    . $(repos -get-dir spack)/share/spack/setup-env.sh
}

function check-alert-file(){
    local alert_file="$1"
    if [ -e "${alert_file}" ] ; then
        printf "\033[1;31m Alert from %s\n" "${alert_file}" >&2
        cat "${alert_file}"
    fi
}

function configure_history(){
    # https://stackoverflow.com/a/19533853/5795941
    # Other contexts may truncate the history, namely some people have said that
    # history may get truncated at bash startup before these two settings have
    # taken effect.  Therefore, we set the history to unlimited size, and only
    # after doing that we set the history file to a different file.
    HISTSIZE=-1
    HISTFILESIZE=-1
    HISTIGNORE="rm -rf *"
    HISTFILE=~/.eternal_bash_history
    HISTTIMEFORMAT=$'\033[1;32m%Y-%m-%d \033[1;33m%H:%M:%S\033[0m '
}


function _source_dir(){
    local dir="$1"
    if ! [ -d "$1" ] ; then
        return 1
    fi
    local f
    for f in $(command env -i ls $dir) ; do
        if ! ( [[ "$f" = *.sh ]] || [[ "$f" = *.bash ]] ) ; then
            continue
        fi
        if ! source "$dir/$f" ; then
            p.error "sourcing '$dir/$f' returned non-zero"
        fi
    done
}

function configure_vim(){
    complete -o default -F _gcps_complete_colon_paths vim
    function vim()(
        if [[ $(hostname) != ppp* ]] ; then
            /usr/bin/vim -p "$@"
            return
        fi

        if [[ "${1}" == */* ]] ; then
            if ! [[ -d "${1%/*}" ]] ; then
                printf "vim(): \033[1;31mERROR\033[0m: dirname(\$1) = '${1%/*}' is not a directory\n"
                return 1
            fi
        fi

        if [[ "$#" == 0 ]] ; then
            set -- .
        fi

        #
        # Add $d/include for all the directories of CMAKE_PREFIX_PATH
        # and for all environment variables of the form <X>_DIR
        # so that YouCompleteMe will look in those directories
        #
        for d in ${CMAKE_PREFIX_PATH//:/ } ; do
            C_INCLUDE_PATH=${d}/include${C_INCLUDE_PATH:+:${C_INCLUDE_PATH}}
        done

        while IFS='=' read -r -d $'\0' k v ; do
            if [[ "${k}" = *_DIR ]] ; then
                C_INCLUDE_PATH=${v}/include${C_INCLUDE_PATH:+:${C_INCLUDE_PATH}}
            fi
        done < <(env -0)
        export C_INCLUDE_PATH
        # echo "C_INCLUDE_PATH=${C_INCLUDE_PATH}"
        gcps_wrap_command_colon_paths command vim -p "$@"
    )
}


################################################################################
# PROBLEM: If you have 'set colored-stats on' in your ~/.inputrc, readline will
# color completion candidates according to LS_COLORS.  Therefore it will color
# anything that is not a file (program options) according to the as 'missing
# files' which if you have 'mi=01;05;37;49' in your LS_COLORS is bold blinking
# bright white on red background which is super annoying.

# SOLUTION: Since readline parses LS_COLORS at initialization and never again
# after that, the trick is to set 'mi=00' in LS_COLORS, then do anything that
# causes readline to be initialized, and then set LS_COLORS back to its
# original value.  Alternatively we could just not put anything for missing
# files in LS_COLORS but I wanted figure out a way to have some coloring for
# missing files
#
# RELEVANT CODE FROM READLINE
# In http://git.savannah.gnu.org/cgit/bash.git/tree/lib/readline/:
# - In parse_colors.c:300 Function _rl_parse_colors() parses LS_COLORS
# - In readline.c:1322 Function readline_initialize_everything calls
#   _rl_parse_colors();
# - In readline.c:1183 Function rl_initialize() calls readline_initialize_everything()
#   only if rl_initialized == 0 then sets rl_initialized to 1 so that it
#   is never called again and does "other stuff".  Future calls to
#   rl_initialize() only do the "other stuff"
# - In realine.c:354 Function readline(), rl_initialize() is called everytime
#   but after the first time, it only does the "other stuff".
#
# IMPORTANT: This needs to be done before anything else causes the otherwise
# the initialization will already have happened with whatever LS_COLORS was at
# that time.  For example, fzf initialization does many 'bind x y' commands
# which initializes readline
################################################################################
set_ls_colors_for_readline_and_ls(){

    :
    # Set LS_COLORS however you like
    # eval "$(dircolors -b)"

    # # Initialize readline with those same LS_COLORS except for the 'mi' part
    local my_ls_colors="${LS_COLORS}"
    LS_COLORS="$(echo "${LS_COLORS}" | sed 's/mi=[0-9;]*/mi=00/')"
    bind -f ~/.inputrc # Anything that causes initialization of readline library

    # # Put back the 'mi' part in LS_COLORS
    # # We need the 'show-colored-stats' to be for BASH only in ~/.inputrc since
    # # the python interpreter will initialize readline in its process and will
    # # read LS_COLORS.  Anyway, we don't want show-colored-stats in Python so
    # # that is totally OK.
    LS_COLORS="${my_ls_colors}"
}

p.notes(){
    echo '${X@P}: The value of X passed through prompt evaluation'
    echo '${X@Q}: Quote the value of X for use as unquoted input'
    echo '${X@a}: Attributes of variable X as printed by declare -p X'
    echo '${X:_Y}: (_ is -,=,+,?): Do something if X is unset or null, but without the colon, it just checks for unset.'
}

glcurl-project-job(){
    if [[ "$1" == -h ]] || (( $# != 2 )); then
        echo "${FUNCNAME[0]} PROJECT_ID JOB_ID"
        echo ""
        echo "Show subset of job information using jq"
        if [[ "$1" == -h ]] ; then
            return 0
        else
            echo "ERROR: Two arguments required"
            return 1
        fi
    fi
    resp="$(glcurl /projects/$1/jobs/$2)"
    if [[ "${resp}" != {\"id\"* ]] ; then
        jq <<< ${resp}
        return 1
    fi
    jq '{id,stage,name,web_url,ref,tag,pipeline:.pipeline|{id,web_url},user:.user|{id,name,location,organization},commit:.commit|{short_id,message,author_name}}' <<< "${resp}"
}


command_not_found_handle(){
    local pack=$HOME/.profile.d/interactive/pack/$1
    if [[ -f "${pack}" ]] ; then
        p.use $1
        unset -f command_not_found_handle
        "$@"
    else
        echo "bash: $1: command not found" >&2
        return 127
    fi
}

p.unresolved-repodir(){
    local candidate=$(
        local prev=$PWD
        while true ; do
            if ! git rev-parse --is-inside-work-tree &>/dev/null ; then
                echo "${prev}"
                return 1
            fi
            prev=$PWD
            cd ..
        done
    )
    local true_repo_dir
    if ! true_repo_dir=$(git rev-parse --show-toplevel 2>/dev/null) ; then
        return 1
    fi

    local candidate_inode=$(stat --format=%i ${candidate})
    local repo_inode=$(stat --format=%i ${true_repo_dir})
    if [[ ${candidate_inode} == ${repo_inode} ]] ; then
        echo ${candidate}
    else
        echo "Unresolved root '${candidate}' is not the same directory as true repo root" >&2
        echo "${true_repo_dir}"
    fi
}

p.find_path_var(){
    local -n path_var=$1 ; shift
    # local to_find=$2
    find ${path_var//[:, ;]/ } "$@"
}
_p.find_path_var(){
    local cur prev words cword
    _init_completion || return
    echo "cword=${cword}" >> ~/.log.txt
    if ((cword > 1)) ; then
        if ! _find 2>/dev/null ; then
            __load_completion find && _find
        fi
    else
        COMPREPLY=($(compgen -v -- "${cur}"))
    fi
}
complete -F _p.find_path_var p.find_path_var
p.go-build(){
    local builds
    if ! builds=($(p.find-build)) ; then
        return 1
    fi

    case ${#builds[@]} in
        0) echo "No builds" ; return 1 ;;
        1) printf "\033[33mcd %s\n" "${builds[0]}"
           cd ${builds[0]} ; return ;;
    esac

    local -A map
    for build in "${builds[@]}" ; do
        local base=${build##*/}
        map[${base}]=${build}
    done

    local choice
    select choice in "${!map[@]}" ; do
        printf "\033[33mcd %s\n" "${map[${choice}]}"
        cd ${map[${choice}]}
        return
    done
}
alias gb=p.go-build

p.find-build(){
    local super
    if ! super=$(git superproject-root) ; then
        return 1
    fi

    while read result ; do
        echo ${result%%/CMakeCache.txt}
    done < <(find ${super} -maxdepth 2 -name CMakeCache.txt)
}
utc-to-local(){
    local date=$1 ; shift
    TZ=America/Toronto date -d "$date UTC" "$@"
}
utc-now(){
    date -u "$@"
}
local-to-utc(){
    local date=$1 ; shift
    TZ=America/Toronto date -u -d "$date EDT" "$@"
}

rsync-help(){

    local bold=$'\033[1;37m'
    local clear=$'\033[0m'
    cat <<- EOF

	Only the trailing slash on the source argument(s) makes a difference.

	These two will copy the ${bold}content${clear} of some/dir/ ${bold}into${clear}
	some/dir/ on host:

	    rsync -r some/dir/ host:some/dir
	    rsync -r some/dir/ host:some/dir/

	These two copy the ${bold}directory${clear} some/dir ${bold}into${clear} some/
	on host:

	    rsync -r some/dir host:some
	    rsync -r some/dir host:some/

	All four of the above commands will create dir on host.

	The commands

	    rsync -r some/dir host:some/dir
	    rsync -r some/dir host:some/dir/

	will leave you with some/dir/dir on host whose content will be the content
	of some/dir at the source.

	EOF
}

rsync(){

    #
    # Normalize arguments using getopt
    #
    eval local normalized_args=($(getopt -n "" --longoptions recursive -o "ra" -- "$@" 2>/dev/null || true))

    #
    # Check if there is a '-r' in the arguments
    #
    local -i i=0
    while (( i < ${#normalized_args[@]} )) ; do
        case "${normalized_args[i]}" in
            -r|--recursive) has_r=true ;;
            --) ((i++)) ; break ;;
        esac
        ((i++))
    done

    #
    # Collect positional argumetns
    #
    local posargs=()
    while (( i < ${#normalized_args[@]} )) ; do
        posargs+=("${normalized_args[i]}")
        ((i++))
    done

    #
    # If no '-r', just do the command without checks
    #
    if ! ${has_r} ; then
        command rsync "$@"
        return
    fi

    #
    # Warn of probably unwanted situation: for example,
    #   rsync localhost:/some/path/model_data remote_host:/some/path/model_data
    # which would leave us with /some/path/model_data/model_data.
    #
    # No trailing slash on first arg means we copy first arg *into* second arg.
    if [[ "${posargs[0]}" != */ ]] ; then
        # We consider it to probably not be what the user wants if the
        # basenames of both arguments match.
        local base0=${posargs[0]##*/} # Garanteed no trailing slash
        local base1="$(basename ${posargs[1]})" # Could have a trailing slash,
                                                # basename takes care of that.
        if [[ "${base0}" == "${base1}" ]] ; then
            if [[ "${posargs[1]}" == *:* ]] ; then
                local dest_host=${posargs[1]%%:*}
            else
                local dest_host=localhost
            fi
            local location_at_dest=${posargs[1]##*:}
            echo "This will create ${location_at_dest}/${base1} on ${dest_host}"
            local answer
            read -p "are you sure you want to continue? [y/n] > " answer
            if [[ "${answer}" == "n" ]] ; then
                return 1
            fi
        fi
    fi

    command rsync "$@"
}


# I always forget whether it's SSMUSE_VERBOSE_XTRACE or SSMUSE_XTRACE_VERBOSE
# plus ssmuse-sh checks if the value is == 1, not empty vs non-empty which would
# be more standard.  Every time, it took me like 3 tries to get it so I made
# this function.
p.verbose_ssm(){
    export SSMUSE_XTRACE_VERBOSE=1
}

p.upstream_compare(){
    # Don't think I'll use this very frequently but I thought it would be
    # useful to know.
    git rev-list --count --left-right @{upstream}...HEAD
}

###################### KEEP THIS AT THE END ####################################
p.profile.main
unset -f p.profile.main
unset -f p.profile.main_interactive
