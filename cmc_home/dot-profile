#!/bin/bash

p.error(){
    printf "${FUNCNAME[1]}: \033[1;31mERROR\033[0m: $*\n"
}

#
# I want what this script does to be the first thing you see when opening it
# and to have no "naked" code inside the script except for that thing at the
# top and the call to main at the very end.
#

function p.profile.main(){
    export TZ=America/Toronto
    export LANG=en_US.UTF-8
    export SSM_DEV=/home/ords/cmdd/cmds/nil000/ssm
    export STOW_DIR="$HOME/fs1"
    export PACKAGE_DIR="$STOW_DIR/Cellar"
    export GITLAB_RUNNER_SCIENCE_ORDSOUMET_KEEP_FILES='yas'
    export GONOSUMDB=gitlab.science.gc.ca
    export PATH="$STOW_DIR/bin:$HOME/bin:$HOME/.local/bin${PATH:+:$PATH}"
    export GITLAB_ACCESS_TOKEN="$(cat ~/.ssh/gitlab-access-token)"
    export EDITOR=/usr/bin/vim
    PATH+=":$HOME/tools/go1.19.linux-amd64/bin"
    PATH+=":$HOME/tools/node-v16.13.1-linux-x64/bin"
    PATH+=":$HOME/tools/rust0.69.0-x86_64-unknown-linux-gnu/bin"
    . ssmuse-sh -x /fs/ssm/hpco/exp/ssm/ssm-12.0-beta1 \
                -x /fs/ssm/hpco/exp/ssmuse/ssmuse-1.13-beta2
    if [[ "$-" == *i* ]] ; then
        p.profile.main_interactive
    fi
}

function p.profile.main_interactive(){
    # p.check-processes
    # p.nice-completion
    # Remove that thing where it looks for Ubuntu packages if a command is not found
    # unset command_not_found_handle
    export PYTHONSTARTUP=~/.pyrc
    export PACK_DIR=${HOME}/.profile.d/interactive/pack

    # Set directories for lazy loading of bash completions
    # See function '_completion_loader' from /usr/share/bash-completion/bash_completion.
    # It looks in ${BASH_COMPLETION_USER_DIR}/completions and <X>/completions
    # for each directory in the colon separated list of paths XDG_DATA_DIRS.
    #
    # This is the simplest way but for things like source, this lazy loading
    # will not happen since ordenv already sets up a broken completion function
    # for source and . and I can't do it for ssmuse-sh and r.load.dot because
    # they are not commands but files that are sourced.
    #
    # Anyway, the lazy loading is a good mechanism for all the system commands
    # since there are like a thousand of them but for my own stuff since there
    # are about 20 of them.
    BASH_COMPLETION_USER_DIR=${HOME}/.bash_completion.d
    # Fun fact, I carelessly had 'XDG_DATA_DIRS=${HOME}/fs1/etc/bash-completion'
    # and had no problems until I started trying to use VSCode.  It was crashing
    # but not under all circumstances.  The reason for modifying XDG_DATA_DIRS
    # initially was because I saw that the bash-completion shell library looks
    # there to lazy load completions for commands.
    XDG_DATA_DIRS=${XDG_DATA_DIRS:+${XDG_DATA_DIRS}:}${HOME}/fs1/etc/bash-completion
    check-alert-file ~sici000/alert
    check-alert-file ~/alert

    set_ls_colors_for_readline_and_ls

    source "$HOME/.ssh/ssh_functions.sh"
    # source "$HOME/.funky-prompt.sh"
    source "$HOME/shell_lib/powerline.sh"; __next_line_mode
    # source $HOME/A_CLASSER/git-colon-path-support.bash
    SOURCE_COMPLETE_EXCLUDE_EXECUTABLE=""
    SOURCE_COMPLETE_ONLY_TEXT_FILES="yes"
    GIT_CD_VERBOSE=yes
    source $HOME/shell_lib/git-colon-path-support.bash
    source $HOME/shell_lib/impersonate.sh
    # Append to global history after every command.
    # .funky-prompt.sh sets PROMPT_COMMAND
    # so this next line must come AFTER sourcing ~/.funky-prompt.sh
    PROMPT_COMMAND="$PROMPT_COMMAND; history -a"
    # Replaced by single files in ~/bin
    # maybe-source "$HOME/shell_lib/gem-functions.sh"
    maybe-source "$HOME/shell_lib/maestro-functions.sh"

    # _source_dir "$HOME/.bash_completion.d"
    _source_dir "$HOME/fs1/etc/bash_completion.d"
    _source_dir "$HOME/fs1/etc/profile.d"

    alias print_args='__print_args "$@"'
    alias ls='ls --color -h'
    alias grep='grep -n --color'
    alias tree='tree -C'
    alias rmb='rm -rf ../build/*'
    # From /etc/profile.d/which2.sh It makes which report what type reports but it only works on RHEL
    # alias which='(alias; declare -f) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot'

    HISTSIZE=-1
    HISTFILESIZE="A non numeric value inhibits truncation"
    HISTIGNORE="rm -rf *"
    # A bit too whimsical
    # HISTTIMEFORMAT=$'\033[1;32m%y-%m-%d \033[1;33m%H\033[0m:\033[1;34m%M\033[0m:\033[1;31m%S\033[0m '
    HISTTIMEFORMAT=$'\033[1;32m%Y-%m-%d \033[1;33m%H:%M:%S\033[0m '

    # Merci Philippe Blain :D
    shopt -s direxpand

    if [[ "${PBS_ENVIRONMENT}" == PBS_INTERACTIVE ]] ; then
        printf "PBS_ENVIRONMENT detected, cd'ing to \$PBS_O_WORKDIR=${PBS_O_WORKDIR}\n" >&2
        cd "${PBS_O_WORKDIR}" || return
        echo "${PBS_JOBID}" > ~/.ssh/current_job
        echo "JOBID ${PBS_JOBID} written in ~/.ssh/current_job" >&2
    fi

    reminders

    # Cd
    alias cd=__cd_or_git_cd
    complete -o nospace -F _cd_or_git_cd cd

    # ls
    alias ls='wrap_command_colon_paths ls --color'
    complete -o default -F __complete_git_colon_paths ls

    configure_vim
}


function maybe-source(){
    if [ -f "${1}" ] ; then
        source "$1"
    fi
}


function check-alert-file(){
    local alert_file="$1"
    if [ -e "${alert_file}" ] ; then
        printf "\033[1;31m Alert from %s\n" "${alert_file}" >&2
        cat "${alert_file}"
    fi
}

function maybe-load-ordenv(){
    if [ -e ~/.ordenv-mode ] || [ -e ~/.maestro-mode ] ; then
        p.ordenv
    fi
}

function maybe-load-maestro(){
    if [ -e ~/maestro-mode ] ; then
        p.use-maestro
    fi
}

lsl(){
    ls --color=always -la "$@" | less -R
}

lsg(){
    ls --color=always -la | grep "$@"
}

#
# Since I put my gitlab access token in an environment variable, and for
# troubleshooting I often dump my environment to a file, I don't want to
# have my gitlab access token visible to anyone who looks at that file
# and I don't want to have to remember to change that files permissions
#
dots(){
    sed 's/./‚óè/g' <<< "$1"
}

#
# - Change "GITLAB_ACCESS_TOKEN=<the-token>" to "GITLAB_ACCESS_TOKEN=<dots>"
#   only because I think it's cool and it took me two seconds to code.
# - Change lines "BASH_FUNC_thing(){ stuff" to "BASH_FUNC_thing(){ stuff [...] }"
# - Remove all lines starting with a space because they are part of multiline
#   values of those BASH_FUNC_thing
dump-env(){
    command env "$@" \
        | sed "s/^GITLAB_ACCESS_TOKEN=.*/GITLAB_ACCESS_TOKEN=$(dots "$GITLAB_ACCESS_TOKEN")/" \
        | sed 's/\(^BASH_FUNC.*\)/\1 \x1b[33m[...]\x1b[0m }/' \
        | command grep -v '^}$\|^ ' \
        | sort
}

# DONT USE: Leaving it here to remind myself that this is
# in fact not equivalent to putting thins in inputrc: by
# using this function instead of inputrc, I wasn't getting
# any colored-stats during my autocompletions.

# Each line is equivalent to putting the content of
# the single quotes in ~/.inputrc
function p.nice-completion(){
    bind 'set colored-stats on'
    bind 'set colored-completion-prefix on'
    bind 'set visible-stats on'
}

function p.set-menu-complete(){
    # I think these things can go in the ~/.inputrc file, I know that
    # make tab cycle through commands after listing
    bind '"\t":menu-complete'
    bind "set show-all-if-ambiguous on"
    bind "set completion-ignore-case on"
    bind "set menu-complete-display-prefix on"
}


function p.set-web-proxy(){
    # From ~sbf000/.profile.d/interactive/post
    # except that I he had https_proxy=http://  and HTTPS_PROXY=http://
    # and I did            https_proxy=https:// and HTTPS_PROXY=https://
    # EDIT: Turns out my extra 's' at the end was making
    # things not work.
    local p=http://webproxy.science.gc.ca:8888/
    export http_proxy=${p}
    export https_proxy=${p}
    export HTTP_PROXY=${p}
    export HTTPS_PROXY=${p}
}

function p.unset-web-proxy(){
    unset http_proxy
    unset https_proxy
    unset HTTP_PROXY
    unset HTTPS_PROXY
}

function _source_dir(){
    local dir="$1"
    if ! [ -d "$1" ] ; then
        # No echo so this function can be called on non-existant dirs
        # echo "${FUNCNAME[0]} ERROR: \$1='$1' is not a directory" >&2
        return 1
    fi
    local f
    for f in $(command env -i ls $dir) ; do
        if ! source "$dir/$f" ; then
            echo "${FUNCNAME[0]} ERROR: sourcing '$dir/$f' returned non-zero" >&2
        fi
    done
}


function p.dqsubi(){
    if ! [ -e "$1" ] ; then
        echo "ERROR: File '$1' does not exist" >&2
        return 1
    fi

    if ! tempfile="$(mktemp qsubi-decorated-job-XXXXXXXX.sh)" ; then
        echo "ERROR: Could not create tempfile" >&2
        return 1
    fi

    # Job must have '#!/bin/bash' otherwise it "doesn't work"
    cat "$1" | decorate-script -cd -shebang >> "${tempfile}"

    chmod +x "${tempfile}"
    qsub -I -- "${tempfile}"
    rm "${tempfile}"
}

function p.pipeqsubi(){
    # This funciton shows that we can use the 'script' command to run 'qsubi -I'
    # when stdin is not a TTY.
    #
    # If we wanted to have shell script that would run something interactively
    # for us using qsub -I directly, it will complain that STDIN is not a tty 
    # and refuse to do its thing.
    if ! tempfile="$(mktemp qsubi-decorated-job-XXXXXXXX.sh)" ; then
        echo "ERROR: Could not create tempfile" >&2
        return 1
    fi

    decorate-script -cd -shebang >> "${tempfile}"

    chmod +x "${tempfile}"
    script -c "qsub -I -- \"${tempfile}\""
    # rm "${tempfile}"
}

function gitk(){
   command gitk --all "$@" &
}

function orgman(){
    pandoc --standalone -f org -t man $1 | /usr/bin/man -l -
}

function p.setup-gnu(){
    time {
        source "$(repos -get-dir ci-env)/latest/rhel-8-amd-64/gnu-9.3.0.sh"
        export PHIL_EC_ENV=gnu${PHIL_EC_ENV:+|${PHIL_EC_ENV}}
        complete -o default source .
    }
}

function _p.require_ordenv()
{
    if [ -z "$ORDENV_SETUP" ] ; then
        p.ordenv 1>&2
    fi
}

function p.myjobs()
{
    (
        _p.require_ordenv
        jobst | grep "${USER}" -n
        exec 1>/dev/null
    )
}

function p.clearjobs()
{
    (
        _p.require_ordenv
        for jobid in $(jobst -u $USER | grep $USER | cut -d '|' -f 1) ; do
            while jobdel ${jobid} > /dev/null 2>&1
            do
                echo "Killing job '${jobid}'" >&2
                sleep 3
            done
            echo "" >&2
            echo "Job '${jobid}' successfully killed." >&2
        done
    )
}


function p.realpath(){
    local pyfunc="${FUNCNAME[0]##p.}"
    python3 -c "import os; print(os.path.${pyfunc}('$1'))"
}

function p.normpath(){
    local pyfunc="${FUNCNAME[0]##p.}"
    python3 -c "import os; print(os.path.${pyfunc}('$1'))"
}

function p.relpath(){
    if [[ "$1" == "" ]] ; then
        echo "${FUNCNAME[0]}: ERROR: Missing argument

USAGE: ${FUNCNAME[0]} PATH [START]" >&2
        return 1
    fi
    local pyfunc="${FUNCNAME[0]##p.}"
    python3 -c "import os; print(os.path.${pyfunc}('$1', start='$2'))"
}

function emacs-daemon(){
    echo "Starting detatched tmux session named 'emacs-daemon' on '$(hostname)'" >&2
    tmux new -s emacs-daemon -d
    echo "Sending keys 'emacs --fg-daemon' to session" >&2
    tmux send-keys -t emacs-daemon 'emacs --fg-daemon
'
}

function vimf(){
    local directory=$1
    vim -p $(find ${directory} -type f)
}


function sshpwd(){
    # Replace things like /fs/homeu1/eccc/cmd/cmds/<rest>
    # with /home/<rest>
    local dir="$(echo $PWD | sed 's/\/fs\/homeu[12]\/[a-z]\+\/[a-z]\+\/[a-z]\+/\/home/')"
    ssh -t "$@" "cd $dir ; bash -l"
}

function cddrw(){
    local cmd=$1
    if ! which "${cmd}" 2>/dev/null ; then
        >&2 echo -e "Usage : ${FUNCNAME[0]} CMD

CMD must be a command"
        return 1
    fi
    local command_location
    command_location="$(dirname "$(readlink -f "$(which "${cmd}")")")"
    printf "\033[33mcd %s\033[0m\n" "${command_location}" >&2
    cd "$command_location" || return
}

function cdd(){
    local filepath=$1
    if [[ -d ${filepath} ]] ; then
        printf "${FUNCNAME[0]}: Warning: argument '${filepath}' is a directory.  Perhaps use cd or cdr\n" >&2
    fi

    local dir
    if ! dir=$(dirname ${filepath}) ; then
        printf "${FUNCNAME[0]}: ERROR: Could not get dirname for '${link_target}'"
        return 1
    fi

    builtin cd ${dir}
}

function cddr(){
    local filepath=$1
    if [[ -d ${filepath} ]] ; then
        printf "${FUNCNAME[0]}: Warning: argument '${filepath}' is a directory.  Perhaps use cd or cdr\n" >&2
    fi
    local link_target
    if ! link_target=$(readlink ${filepath}) ; then
        printf "${FUNCNAME[0]}: ERROR: Could not follow link '${filepath}'"
        return 1
    fi

    local dir
    if ! dir=$(dirname ${link_target}) ; then
        printf "${FUNCNAME[0]}: ERROR: Could not get dirname for '${link_target}'"
        return 1
    fi

    builtin cd ${dir}
}


# Documentation and shortcut for debugging with debugpy and vscode.
function p.debugpy(){
    if [[ "$1" == [0-9]* ]] ; then
        local port=$1; shift
    fi
    local file=$1
    if [ -z $file ] ; then
        printf "USAGE: p.debugpy [PORT] FILE [ARGS ...]

The PORT argument is detected as a string of only digits.  Therefore this command doesn't
work if your filename is only digits but that would be weird.

Run the command and launch the corresponding configuration in VSCode.  It should look like
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    \"version\": \"0.2.0\",
    \"configurations\": [
        {
            \"name\": \"Attach\",
            \"type\": \"python\",
            \"request\": \"attach\",
            \"connect\": {
                \"host\": \"localhost\",
                \"port\": 5678
            },
            // With this setting set to false, the debugger will enter library
            // functions.  Otherwise, doing 'step into' while on a library
            // function makes us jump over the function, confusing the audience.
            \"justMyCode\": false
        }
    ]
}
\033[1;31mERROR\033[0m: No file specified\n"
        return 1
    fi
    port=${port:-5678}
    cmd='python3 -m debugpy --wait-for-client --listen $port "$@"'
    printf "Launching waiting debugger: \033[1;32m%s\033[0m\n" "$(eval echo $cmd)"
    eval $cmd

}

function p.org-tangle(){
    #
    # Note where the file appears in the command.  I tried to
    #     emacs --batch -l org -f org-babel-tangle "$@"
    # because it was simpler but it did not work giving
    #     wrong type argument: stringp, nil
    # so I think that the file has to be specified before doing
    # the -f thing.  Or rather, a filename has to have already
    # been read before -f is seen by the command parsing code.
    #
    local file=$1
    shift
    cmd='emacs --batch -l org --eval "(setq org-src-preserve-indentation t)" ${file} -f org-babel-tangle "$@"'
    printf "Emacs batch command : \033[1;32m%s\033[0m\n" "$(eval echo $cmd)"
    eval $cmd
}

################################################################################
# Remove from end of line.  This function was made because
# when doing org-babel-tangle in emacs on Windows, even if the
# file is a UNIX file with LF opened through TRAMP, when tangling
# the resulting file has CRLF line endings.  Another way is to use
# the above function p.org-tangle on the UNIX system.  If however
# the emacs on that system is not the right version or is
# missing some packages, then it may only be possible to tangle
# it correctly on the Windows machine's emacs.  In that case
# this function can be used on the file after.
################################################################################
function p.crlf-to-lf(){
    local file=$1
    cmd="sed 's/^M$//' \"\$@\""
    printf "sed command: \033[1;32m%s\033[0m\n" "${cmd}"
    sed 's/
$//' "$@"
}


################################################################################
# Case insensitive glob find
################################################################################
function p.igfind(){
    find . -iname "*$1*"
}

function p.vstm(){
    ~/my_scripts/vscode-tmux-session.sh
}

function p.clean-vstm(){
    rm -f ~/.vscode-tmux-sockets/*
}

function p.myprocs(){
    ps -F -u "$USER"
}

function p.tcheck(){
    local nb_tmux
    nb_tmux=$(pgrep -au "$USER" tmux | wc -l)
    local tmux_color=""
    if ((nb_tmux > 15)) ; then
        tmux_color="\033[1;31m"
    elif ((nb_tmux > 10)) ; then
        tmux_color="\033[1;33m"
    fi

    printf "${tmux_color}Number of tmux procs : %s\033[0m\n" "${nb_tmux}"
}

function p.pcheck(){
    local nb_procs
    nb_procs=$(ps -u "$USER" | wc -l)
    local proc_color=""
    if ((nb_procs > 200)) ; then
        proc_color="\033[1;31m"
    elif ((nb_procs > 150)) ; then
        proc_color="\033[1;33m"
    fi
    printf "${proc_color}Number of processes  : %s\033[0m\n" "${nb_procs}"
}

function p.check-processes(){
    p.pcheck
    p.tcheck
}

function p.unansi(){
    sed 's/\x1b\[[0-9;]*m//g' "$@"
}

function p.qsubi(){
    qsub -I -lselect=1:ncpus=80:mem=201gb "$@"
}

function p.quiet-make(){
    # Most PRN-SI projects have set(CMAKE_VERBOSE_MAKEFILE TRUE) which
    # means the makefiles verbose by default and require an explicit
    # 'VERBOSE=' (setting to nothing) to make them non-verbose
    PHIL_VERBOSE_MAKE=""
}

function p.verbose-make(){
    # Most PRN-SI projects have set(CMAKE_VERBOSE_MAKEFILE TRUE) which
    # means the makefiles verbose by default and require an explicit
    # 'VERBOSE=' (setting to nothing) to make them non-verbose
    PHIL_VERBOSE_MAKE=1
}


function make(){
    if ! on_compute_node ; then
        local arg
        for arg in "$@" ; do
            if [[ "${arg}" == -j* ]] ; then
                echo "You are on host ${HOSTNAME} ... you should not use '-j'.  Use 'command make $*' to bypass this function if you are sure"
                return 1
            fi
        done
    fi
    command make VERBOSE=${PHIL_VERBOSE_MAKE} "$@"
}


function p.dusage(){
    du --max-depth=1 -h | sort -h
}

p.pgrep(){
    #  -f, --full
    #         The  pattern is normally only matched against the
    #         process name.  When -f is set, the  full  command
    #         line is used.
    #
    pgrep -u $USER -f "$@"
}

p.ps(){
    # Note, 
    ps -f -u $USER --cols $(tput cols) | sort -k 8
}
p.pst(){
    # Note, 
    ps f -f -u $USER
}

p.check_procs_pppn(){
    local pppn=${1}
    if ! echo ${pppn} | grep -P "(ppp5)|(ppp6)" &>/dev/null ; then
        echo "Argument 1 must be ppp5 or ppp6"
        return 1
    fi

    for node in ${pppn}login-001 ${pppn}login-002 ; do
        printf "\033[1;32mLogging in to $node\033[0m\n"
        ssh -t -J${pppn} ${node} 'ps -u phc001 -f'
    done
}

p.check_procs_all(){
    for pppn in ppp5 ppp6 ; do
        printf "\033[1;35mChecking nodes on ${pppn}\033[0m\n"
        p.check_procs_pppn ${pppn}
    done
}


################################################################################
# Acquire compute node for building and running GEM (or anything else)
################################################################################
function p.qsubi(){
    qsub -I -lselect=1:ncpus=72:mem=50gb "$@"
}


function vimw(){
    local cmd=$1
    if [[ -z "${cmd}" ]] ; then
        echo "${FUNCNAME[0]}: ERROR: Please provide a command"
        return 1
    fi

    local cmd_path
    if ! cmd_path=$(which ${cmd}) ; then
        echo "${FUNCNAME[0]}: ERROR: Command not found using which"
        return 1
    fi
    vim ${cmd_path}
}

function _errprint(){
    printf "${FUNCNAME[1]}: \033[1;31mERROR\033[0m: $*\n" >&2
}

function do_error(){
    _errprint "An error happened, oh no!"
}

function p.view_listing(){
    local compressed_listing=$1
    if ! [[ -f "${compressed_listing}" ]] ; then
        # printf "${FUNCNAME[0]}: \033[1;31mERROR\033[0m: Listing '${compressed_listing}' does not exist\n"
        _errprint "Listing '${compressed_listing}' does not exist"
        return 1
    fi
    # Assume that mktemp always succeeds
    local tempfile=$(mktemp uncompressed_listing_XXXXXX.sh)
    gunzip -c ${compressed_listing} > ${tempfile}
    vim ${tempfile}
    if ! rm ${tempfile} ; then
        _errprint "Could not remove '${tempfile}'"
    fi
}

function vim(){
    if [[ $(hostname) == ppp* ]] ; then
        $HOME/fs1/bin/vim "$@"
    else
        /usr/bin/vim "$@"
    fi
}

function configure_vim(){
    complete -o default -F __complete_git_colon_paths vim
    alias vim='wrap_command_colon_paths vim -p'
}

#
# Because $PYTHONSTARTUP is ignored when using the '-i' option, we just
# prepend its content to the python file we are running.
#
py3i(){
    file=$1
    python3 -i -c "$(cat ~/.pyrc $file)"
}


function dump-environment(){
    local envdump_dir=$HOME/envdumps
    mkdir -p ${envdump_dir}
    local envdump_file=$(mktemp env_dump_$(TZ=America/Toronto date +%Y-%m-%d_%H:%M:%S)_XXX.txt --tmpdir=${envdump_dir})
    echo "envdump_file = ${envdump_file}" >&2
    echo "\$0 = '$0'" >> ${envdump_file}
    echo "\$@ = '$@'" >> ${envdump_file}
    command env >> ${envdump_file}
}

function reminders(){
    printf "\033[0mC-f or ^[L does shell-forward-word (.inputrc)\n" >&2
    printf "\033[0m^[l does forward-word (.inputrc)\n" >&2
    printf "\033[0mC-b or ^[H does shell-backward-word (.inputrc)\n" >&2
    printf "\033[0m^[h does backward-word (.inputrc)\n" >&2
    printf "\033[0mC-t does C-aC-fC-w (change command)\n" >&2
    printf "\033[0mC-xp does \"prepend edit PATH\"\n" >&2
}

function xargso(){
    if [[ "${1}" == "" ]] ; then
        printf "${FUNCNAME[0]}: \033[1;31mERROR\033[0m: At least one argument must be give\n"
        return 1
    fi
    if [[ "${1}" == -h ]] ; then
        printf "${FUNCNAME[0]} does the equivalent of 'xargs -o' on BSD"
        printf "which is to reopen STDIN as /dev/tty in the child process\n"
        printf "This is useful to when opening an interactive application\n"
        printf "like vim\n"
        return 0
    fi
    cmd="$@ \"\$@\" </dev/tty"

    print_args xargs sh -c "${cmd}"
    printf "===============================\n"
    print_args xargs sh -c "${cmd}" "$@"
    printf "===============================\n"
    xargs sh -c "${cmd}" fuckface
    # xargs sh -c "${cmd}" "$@"
    # this does not work :
    # xargs sh -c "$@ \"\$@\" </dev/tty"
    print_args xargs sh -c "$@ \"\$@\" </dev/tty"
}


function x.use(){
    local pack_dir="${1}"
    shift
    if [[ -z "${1}" ]] ; then
        echo "${FUNCNAME[1]}: ERROR: An argument must be provided"
        return 1
    fi

    local pack_name="${1}"
    if ! [[ -f ${pack_dir}/${pack_name} ]] ; then
        echo "${FUNCNAME[1]}: ERROR: No package named '${pack_name}' in ${pack_dir}"
        return 1
    fi

    shift
    local status
    #source ${pack_dir}/${pack_name} "$@" 
    local i=0
    while IFS= read -r line ; do
        : $((i++))
        if [[ -z "${line}" ]] ; then
            continue
        fi
        printf "\033[1;32m${FUNCNAME[1]}: ${line}\033[0m\n"
        if ! eval ${line} ; then
            printf "${FUNCNAME[1]}: \033[1;31mERROR\033[0m error on line ${i} of ${pack_dir}/${pack_name}\n"
        fi
    done < ${pack_dir}/${pack_name}
    status=$?
    if [[ ${status} != 0 ]] ; then
        echo "${FUNCNAME[1]}: ERROR: Sourcing '${pack_dir}/${pack_name}' returned an error : $?"
    fi
    return ${status}
}

function p.use(){
    x.use ${PACK_DIR} "$@"
}

function f.use(){
    x.use ~for000/.profile.d/interactive/pack "$@"
}

function __print_args(){
    # Useful to double check how arguments are given to a program.
    # For example, xargso above, the arguments get split /c
    local i=1
    echo "${FUNCNAME[1]}: \$0   = $0"
    echo "${FUNCNAME[1]}: \$#   = $#"
    echo "${FUNCNAME[1]}: args = '$@'"
    for arg in "$@" ; do
        echo "${FUNCNAME[1]}: arg[$((i++))] = $arg"
    done
}

function p.ftake(){
    if [[ -z "${1}" ]] ; then
        p.error "Argument required"
        return 1
    fi
    local to_take="$(echo ~for000/.profile.d/interactive/pack/$1)"

    if ! [[ -f ${to_take} ]] ; then
        p.error "Package to take '${1}' does not exist in '~for000/.profile.d/interactive/pack'"
        return 1
    fi

    local new_name
    if [[ -n "${2}" ]] ; then
        new_name=${2}
    else
        new_name=""
    fi

    if ! cp ${to_take} ${PACK_DIR}/${new_name} ; then
        p.error "Could not copy '${to_take}' to '${PACK_DIR}/${new_name}'"
        return 1
    fi
}

log(){
    echo "${FUNCNAME[1]}: $*" >> ~/.log.txt
}

_x.use(){
    local pack_dir=$1
    local prev cur words cword
    log "================================================================="
    _init_completion || return

    log "prev=${prev}, cur=${cur}, words=${words[@]}, cword=${cword}"
    case ${cword} in
        0) echo "Can't happen!" ;;
        1) COMPREPLY=($(compgen -W "$(cd ${pack_dir} ; command ls | command grep -v '^_')" -- ${cur})) ;;
        2|*) _dispatch_pack_complete ${prev} ;;
    esac
}

_p.use(){
    _x.use ${PACK_DIR}
}

_f.use(){
    _x.use ~for000/.profile.d/interactive/pack
}

#
# Default is not applied here because p.use's first argument cannot be a file
# from PWD (unless we are in ${PACK_DIR} but those will get suggested by _p.use
# anyway.  Instead, we use _filedir to suggest give the default suggestions.
#
complete -F _p.use p.use p.view-pack
complete -F _f.use f.use f.view-pack p.ftake
p.view-pack(){
    vim ${PACK_DIR}/${1}
}
f.view-pack(){
    vim ~for000/.profile.d/interactive/pack/${1}
}

_dispatch_pack_complete(){
    case ${1} in
        code-tools) COMPREPLY=($(compgen -W "gnu intel gnu9" -- ${cur})) ;;
        rpnpy) COMPREPLY=($(cd $HOME ; _filedir)) ;;
        *) _filedir ;;
    esac
}

function show-vars(){
    # Show environment variables and shell variables
    declare -p
}

function show-functions(){(
    # Show all function names with definition location
    shopt -s extdebug
    local functions
    if [[ -n ${1} ]] ; then
        functions=($(declare -F 2>&1 | cut -d ' ' -f 3 | command grep "$1"))
    else
        functions=($(declare -F 2>&1 | cut -d ' ' -f 3))
    fi

    for f in "${functions[@]}" ; do
        declare -F $f
    done | awk '{printf "%c[32m%s %c[1;35m%s %c[1;33m%s%c[0m\n", 27, $1, 27, $2, 27, $3, 27}'
)}

################################################################################
# PROBLEM: If you have 'set colored-stats on' in your ~/.inputrc, readline will
# color completion candidates according to LS_COLORS and if you have something
# it will color anything that is not a file (program options) accordint to the
# as 'missing files' which if you have 'mi=01;05;37;49' in your LS_COLORS is
# bold blinking bright white on red background which is super annoying.
# SOLUTION: Since readline parses LS_COLORS at initialization and never again
# after that, the trick is to set 'mi=00' in LS_COLORS, then do anything that
# causes readline to be initialized, and then set LS_COLORS back to its original
# value.  Alternatively we could just not put anything for missing files in
# LS_COLORS but I wanted figure out a way to have some coloring for missing
# files
# In http://git.savannah.gnu.org/cgit/bash.git/tree/lib/readline/:
# - In parse_colors.c:300 Function _rl_parse_colors() parses LS_COLORS
# - In readline.c:1322 Function readline_initialize_everything
# - In readline.c:1183 Function rl_initialize() calls readline_initialize_everything()
#   only if rl_initialized == 0 then sets rl_initialized to 1 so that it
#   is never called again and does "other stuff".  Future calls to
#   readline_initialize_everything() only do the "other stuff"
# - In realine.c:354 Function readline(), rl_initialize() is called everytime
#   but after the first time, it only does the "other stuff".
################################################################################
set_ls_colors_for_readline_and_ls(){

    # Set LS_COLORS however you like
    eval "$(dircolors -b ~/.dir_colors.256color)"

    # Initialize readline with those same LS_COLORS except for the 'mi' part
    local my_ls_colors="${LS_COLORS}"
    LS_COLORS="$(echo "${LS_COLORS}" | sed 's/mi=[0-9;]*/mi=00/')"
    bind -f ~/.inputrc # Anything that causes initialization of readline library

    # Put back the 'mi' part in LS_COLORS
    # LS_COLORS="${my_ls_colors}"

    # Another option would be to have two files but ideally, you want LS_COLORS
    # for readline to be the same for everything except for the 'mi' part
    # eval "$(dircolors -b ~/.dir_colors.readline)"
    # bind -r ~/.inputrc
    # eval "$(dircolors -b ~/.dir_colors.256color)"
}

# dump-environment
p.env(){
    env -0 | sort -z | tr '\0' '\n'
}


p.profile.main
unset -f p.profile.main
unset -f p.profile.main_interactive
