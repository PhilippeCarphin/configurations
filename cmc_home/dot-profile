#!/bin/bash
# if [[ $TERM == "dumb" ]] ; then
#     # echo "process 12345678 active"
#     # trap 'echo "cleaning up temporary directories"; echo "removing TMPDIR whatever"' EXIT
# 	unset PROMPT_COMMAND
# 	PS1='$ '
# 	return
# fi

main(){
    export STOW_DIR=$HOME/fs1
    export PACKAGE_DIR=$STOW_DIR/Cellar
    export GITLAB_RUNNER_SCIENCE_ORDSOUMET_KEEP_FILES='yas'
    export GONOSUMDB=gitlab.science.gc.ca
    export PATH=$STOW_DIR/bin:$HOME/bin:$HOME/.local/bin${PATH:+:$PATH}
    PATH+=:$HOME/tools/go1.17.5.linux-amd64/bin
    PATH+=:$HOME/tools/node-v16.13.1-linux-x64/bin
    PATH+=:$HOME/tools/rust-1.69.0-x86_64-unknown-linux-gnu/bin
    if [ -e ~/.ordenv ] ; then
        p.ordenv
    fi
    # p.ordenv # for testing purposes
    # This seems to be needed to run maestro experiments (at least ordenv)
    # p.use-maestro
    export GITLAB_ACCESS_TOKEN=$(cat ~/.ssh/gitlab-access-token)
    if [[ "$-" == *i* ]] ; then
        main_interactive
    fi

}

dots(){
    sed 's/./‚óè/g' <<< $1
}

function env(){
    command env "$@" \
        | sed "s/^GITLAB_ACCESS_TOKEN=.*/GITLAB_ACCESS_TOKEN=$(dots $GITLAB_ACCESS_TOKEN)/" \
        | sed 's/\(^BASH_FUNC.*\)/\1 \x1b[33m[...]\x1b[0m }/' \
        | grep -v '^}$\|^ '
}

function p.set-menu-complete(){
    # make tab cycle through commands after listing
    bind '"\t":menu-complete'
    bind "set show-all-if-ambiguous on"
    bind "set completion-ignore-case on"
    bind "set menu-complete-display-prefix on"
}


function p.set-web-proxy(){
    # From ~sbf000/.profile.d/interactive/post
    # except that I he had https_proxy=http://  and HTTPS_PROXY=http://
    # and I did            https_proxy=https:// and HTTPS_PROXY=https://
    # EDIT: Turns out my extra 's' at the end was making
    # things not work.
    export http_proxy=http://webproxy.science.gc.ca:8888/
    export https_proxy=http://webproxy.science.gc.ca:8888/
    export HTTP_PROXY=http://webproxy.science.gc.ca:8888/
    export HTTPS_PROXY=http://webproxy.science.gc.ca:8888/
}

function main_interactive(){
    export LESSOPEN="| /usr/bin/source-highlight-esc.sh %s"
    export LESS=" -R"
    # Remove that thing where it looks for Ubuntu packages if a command is not found
    unset command_not_found_handle
    if [ -e ~sici000/alert ] ; then
        printf "\033[1;31m Alert from sici000\n" >&2
        cat ~sici000/alert
    fi

    if [ -e ~phc001/alert ] ; then
        printf "\033[1;31m Alert from phc001\n" >&2
        cat ~phc001/alert
    fi

    source $HOME/.ssh/ssh_functions.sh
    source $HOME/.simple_git_ps1_example.sh

    _source_dir $HOME/.bash_completion.d
    _source_dir $HOME/fs1/etc/bash_completion.d
    _source_dir $HOME/fs1/etc/profile.d


    alias ls='ls --color -h'
    alias grep='grep --color'
    alias tree='tree -C'
    alias gitk=gitk_all
    alias make='make VERBOSE='
    alias rmb='rm -rf ../build/*'

    export TZ=America/Toronto
    export HISTSIZE=
    export HISTFILESIZE=
    export HISTIGNORE="rm -rf *"

    # Merci Philippe Blain :D
    shopt -s direxpand
}

function _source_dir(){
    dir=$1
    if ! [ -d "$1" ] ; then
        # No echo so this function can be called on non-existant dirs
        # echo "${FUNCNAME[0]} ERROR: \$1='$1' is not a directory" >&2
        return 1
    fi
    for f in $(env -i ls $dir) ; do
        if ! source $dir/$f ; then
            echo "${FUNCNAME[0]} ERROR: sourcing '$dir/$f' returned non-zero" >&2
        fi
    done
}

p.qsubi(){
    if ! [ -e "$1" ] ; then
        echo "ERROR: File '$1' does not exist" >&2
        return 1
    fi
	# SYNOPSIS
	#        qsub [-a <date and time>] [-A <account string>] [-c <checkpoint spec>]
	#             [-C <directive prefix>] [-e <path>] [-f] [-h]
	#             [-I [-G [-- <GUI application/script>]] | [-X]] [-j <join>]
	#             [-J <range> [%<max subjobs]] [-k <discard>] [-l <resource list>]
	#             [-m <mail events>] [-M <user list>] [-N <name>] [-o <path>]
	#             [-p <priority>] [-P <project>] [-q <destination>] [-r <y|n>]
	#             [-R <remove options>] [-S <path list>] [-u <user list>]
	#             [-v <variable list>] [-V] [-W <additional attributes>] [-z]
	#             [- | <script> | -- <executable> [<arguments to executable>]]

    qsub -I -- $1

	# When I try doing it this way with a script, it just puts me in an
    # interactive shell on a compute node and doesn't seem to run my script
	# qsub -I $1
}

p.dqsubi(){
    if ! [ -e "$1" ] ; then
        echo "ERROR: File '$1' does not exist" >&2
        return 1
    fi

    if ! tempfile=$(mktemp qsubi-decorated-job-XXXXXXXX.sh) ; then
        echo "ERROR: Could not create tempfile" >&2
        return 1
    fi

    # Job must have '#!/bin/bash' otherwise it "doesn't work"
    cat $1 | decorate-script -cd -shebang >> ${tempfile}

    chmod +x ${tempfile}
    qsub -I -- ${tempfile}
    rm ${tempfile}
}

p.pipeqsubi(){
    if ! tempfile=$(mktemp qsubi-decorated-job-XXXXXXXX.sh) ; then
        echo "ERROR: Could not create tempfile" >&2
        return 1
    fi

    decorate-script -cd -shebang >> ${tempfile}

    chmod +x ${tempfile}
    script -c "qsub -I -- ${tempfile}"
    rm ${tempfile}
}
gitk_all(){
   command gitk --all $@ &
}

function orgman(){
    pandoc --standalone -f org -t man $1 | /usr/bin/man -l -
}

function p.setup-intel(){
    time {
        # source $(repos -get-dir ci-env)/latest/rhel-8-icelake-64/inteloneapi-2022.1.2.sh
        # source $(repos -get-dir ci-env)/latest/rhel-8-icelake-64/inteloneapi-2022.1.2.sh
        # source $(repos -get-dir ci-env)/latest/rhel-8-amd64-64/inteloneapi-2022.1.2.sh file doesn't exist
        source $(repos -get-dir ci-env)/latest/rhel-8-amd-64/inteloneapi-2022.1.2.sh
        export SSM_DEV=/home/ords/cmdd/cmds/nil000/ssm/workspace
        export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$SSM_DEV/App/lib:$SSM_DEV/rmn/lib:$SSM_DEV/vgrid/lib:
        export PHIL_EC_ENV=intel${PHIL_EC_ENV:+|${PHIL_EC_ENV}}
        complete -o default source .
    }
}

function p.setup-gnu(){
    time {
        source $(repos -get-dir ci-env)/latest/rhel-8-amd-64/gnu-9.3.0.sh
        export PHIL_EC_ENV=gnu${PHIL_EC_ENV:+|${PHIL_EC_ENV}}
        complete -o default source .
    }
}

function p.ordenv()
{

    #
    # Use a temporary file to capture output of a source command since
    # $(source a_file.sh) would lose the effect of sourcing the file.
    #
    # See https://stackoverflow.com/a/66832192/5795941 which confirms that
    # to do this we pretty much have to resort to using a temporary file.
    #
    local ordenv_output_file=$(mktemp $HOME/.ordenv_output_file_XXXXXXXXXXX)

    #
    # Source the official profile
    #
    source ~/.profile_officiel > ${ordenv_output_file} 2>&1
    local ordenv_status=$?

    #
    # Only show the captured output if an error happened during the
    # loading of ORDENV.  Otherwise, just print the last line which
    # should be the line showing the time elapsed during the loading
    # of ORDENV
    #
    if [[ ${ordenv_status} != 0 ]] ; then
        printf "ERRORS occured during loading of ordenv\n" >&2
        cat ${ordenv_output_file} >&2
    else
        printf "Sourcing of ORDENV successful\n" >&2
        tail -n 1 ${ordenv_output_file}
    fi

    #
    # Cleanup tempfile
    #
    rm -f ${ordenv_output_file}

    #
    # Readjust the PATH.  I don't remember why I put this here.  Probably
    # because it prepends something which I would like to see come after
    # my own things in $HOME/fs1.
    #
    export PATH=$HOME/fs1/bin:${PATH}

    #
    # Variable that is shown in my prompt string so that my PS1 can
    # show whether ORDENV is loaded or not.
    #
    export PHIL_EC_ENV=ORDENV${PHIL_EC_ENV:+|${PHIL_EC_ENV}}

    # Loading ordenv messes up autocompletion on the source command
    complete -o default source .
}

function _p.require_ordenv()
{
    if [ -z "$ORDENV_SETUP" ] ; then
        p.ordenv 1>&2
    fi
}

function p.myjobs()
{
    (
        _p.require_ordenv
        jobst | grep ${USER} -n
        exec 1>/dev/null
    )
}

function p.clearjobs()
{
    (
        _p.require_ordenv
        for jobid in $(jobst -u $USER | grep $USER | cut -d '|' -f 1) ; do
            while jobdel ${jobid} > /dev/null 2>&1
            do
                echo "Killing job '${jobid}'" >&2
                sleep 3
            done
            echo "" >&2
            echo "Job '${jobid}' successfully killed." >&2
        done
    )
}

function p.use_linuxbrew(){
   export LD_LIBRARY_PATH=$HOME/.local/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}
   export LD_LIBRARY_PATH=$HOME/.linuxbrew/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}
   export PATH=$HOME/.linuxbrew/bin${PATH:+:${PATH}}
}

function p.realpath(){
    python3 -c "import os; print(os.path.${FUNCNAME[0]##p.}('$1'))"
}

function p.normpath(){
    python3 -c "import os; print(os.path.${FUNCNAME[0]##p.}('$1'))"
}

function p.relpath(){
    if [[ "$1" == "" ]] ; then
        echo "${FUNCNAME[0]}: ERROR: Missing argument

USAGE: ${FUNCNAME[0]} PATH [START]" >&2
        return 1
    fi
    python3 -c "import os; print(os.path.${FUNCNAME[0]##p.}('$1', start='$2'))"
}

function emacs-daemon(){
    echo "Starting detatched tmux session named 'emacs-daemon' on '$(hostname)'" >&2
    tmux new -s emacs-daemon -d
    echo "Sending keys 'emacs --fg-daemon' to session" >&2
    tmux send-keys -t emacs-daemon 'emacs --fg-daemon
'
}

function vim(){
    if [[ "$@" == "" ]] ; then
        command vim -p .
    else
        command vim -p "$@"
    fi
}

function iris-cmake(){
    SSM_DEV=/home/ords/cmdd/cmds/nil000/ssm/workspace
    printf "Using SSM_DEV from \033[1;35mJP\033[0m = ${SSM_DEV}\n" >&2
    # cmd='cmake .. -DApp_ROOT=${SSM_DEV}/App -DUSE_MPI_TRACE=ON -DMPI_TRACE_LIBRARY=$(repos -get-dir mpitrace)/src/libmpitrace.so -Drmn_ROOT=${SSM_DEV}/rmn -Dgeoref_ROOT=${SSM_DEV}/georef "$@"'
    cmd='cmake .. -DApp_ROOT=${SSM_DEV}/App -Drmn_ROOT=${SSM_DEV}/rmn -Dgeoref_ROOT=${SSM_DEV}/georef "$@"'
    printf "Base command \033[34m$cmd\033[0m\n" >&2
    printf "Evaluated command \033[32m$(eval echo $cmd)\033[0m\n" >&2
    eval $cmd
}

function sshpwd(){
    # Replace things like /fs/homeu1/eccc/cmd/cmds/<rest>
    # with /home/<rest>
    local dir="$(echo $PWD | sed 's/\/fs\/homeu[12]\/[a-z]\+\/[a-z]\+\/[a-z]\+/\/home/')"
    ssh -t "$@" "cd $dir ; bash -l"
}

function p.use-maestro(){
    _p.require_ordenv
    . ssmuse-sh -d eccc/cmo/isst/maestro/1.8.4
}

function p.use-cmds-python(){
    # https://gitlab.science.gc.ca/hpc/hpcr_upgrade_2/wikis/python
    . ssmuse-sh -p /fs/ssm/eccc/cmd/cmds/env/python/py39_2022.05.24_rhel-8-icelake-64
}

function p.use-rpnpy(){
    . ssmuse-sh -x rpn/MIG/ENV/d/rpnpy/rpnpy_2.1.6
}

function p.use-python3.9(){
    export PATH=$HOME/tools/cpython-3.9.9/bin:$PATH
}

function p.use-python3.7(){
    # export PATH=$HOME/tools/cpython-3.7.9/bin:$PATH
    export PATH=$HOME/tools/cpython-3.7.9_ctypes/bin:$PATH
}

function p.reload-profile(){
    unset ORDENV_SETUP
    source ~/.profile
}

function p.pip(){
    python3 -m pip --user "$@"
}

function p.ordenv-mode(){
    touch ~/.ordenv
    printf "Activating ordenv mode\n" >&2
}

function p.normal-mode(){
    printf "Deactivating ordenv mode\n" >&2
    rm -f ~/.ordenv
}

function cddrw(){
    local d=$(dirname $(readlink -f $(which $1)))
    printf "\033[33mcd $d\033[0m\n" >&2
    cd $d
}

main
