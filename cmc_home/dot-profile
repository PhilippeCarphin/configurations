#!/bin/bash

p.error(){
    printf "${FUNCNAME[1]}: \033[1;31mERROR\033[0m: $*\n" >&2
}


function p.profile.main(){
    source ~/.philconfig/shell_rc_common
    source ~/.philconfig/shell_rc.bash
    source ~/.philconfig/shell_rc.bash.work
    configure_spack
    configure_vscode_server_environment
    if [[ "$-" == *i* ]] ; then
        p.profile.main_interactive
    fi
}

function p.profile.main_interactive(){
    export PYTHONSTARTUP=~/.pyrc

    set_ls_colors_for_readline_and_ls
    source "$HOME/.ssh/ssh_functions.sh"
    source "$HOME/.philconfig/shell_lib/x.use"
    check-alert-file ~sici000/alert
    check-alert-file ~/alert
    maybe_cd_to_pbs_o_workdir
}

maybe_cd_to_pbs_o_workdir(){
    if [[ "${PBS_ENVIRONMENT}" == PBS_INTERACTIVE ]] ; then
        printf "PBS_ENVIRONMENT detected, cd'ing to \$PBS_O_WORKDIR=${PBS_O_WORKDIR}\n" >&2
        if ! cd "${PBS_O_WORKDIR}" ; then
            p.error "Could not CD to '$PBS_O_WORKDIR', perhaps it is not on a network filesystem"
        fi
        echo "${PBS_JOBID}" > ~/.ssh/current_job
        echo "JOBID ${PBS_JOBID} written in ~/.ssh/current_job" >&2
    fi
}

complete -o default -o nospace -o filenames -F _DottableCompletion source .


################################################################################
# Certain things about our environment setup don't jive well with vscode-server
# so we override them for that case.
# - TMPDIR: contains the PID of the process that loaded ordenv. Otherwise:
#   - parent : lauches a child
#   - child : has TMPDIR which contains PID of parent
#   - parent : detaches child and exits, causing r.cleanup_tmpdir to delete
#              TMPDIR
#   - child : has a TMPDIR which does not exist.
#
################################################################################
configure_vscode_server_environment(){
    # Dump environment to file at very beginning to see what the env looks
    # like when vscode server logs in.
    #
    # env -0 | sort -z | tr '\0' '\n' > ~/env_$(date +%Y-%m-%d_%H.%M.%S)
    #
    if [[ -v VSCODE_AGENT_FOLDER ]] ; then
        export GO111MODULES=off
        export TMPDIR=/tmp/$USER/vscode-server
        mkdir -p ${TMPDIR}
    fi

    # At work, the sshd config is has a slight problem.  The expected behavior
    # is that sshd creates /run/user/$(id -u) and sets XDG_RUNTIME_DIR to that
    # value.  The observed behavior is that it sets XDG_RUNTIME_DIR but does
    # not always create the directory.  Only sshd can create this directory, the
    # user cannot.  To mitigate this, I set it to something else.
    export XDG_RUNTIME_DIR=/tmp/$USER/xdg_runtime_dir
    mkdir -p ${XDG_RUNTIME_DIR}
}

configure_spack(){
    export SPACK_SKIP_MODULES=y
    if [[ -n "${SPACK_SKIP_MODULES}" ]] ; then echo "WARNING: SPACK_SKIP_MODULES is set" >&2 ; fi
    . $(repos -get-dir spack)/share/spack/setup-env.sh
}

function check-alert-file(){
    local alert_file="$1"
    if [ -e "${alert_file}" ] ; then
        printf "\033[1;31m Alert from %s\n" "${alert_file}" >&2
        cat "${alert_file}"
    fi
}



################################################################################
# PROBLEM: If you have 'set colored-stats on' in your ~/.inputrc, readline will
# color completion candidates according to LS_COLORS.  Therefore it will color
# anything that is not a file (program options) according to the as 'missing
# files' which if you have 'mi=01;05;37;49' in your LS_COLORS is bold blinking
# bright white on red background which is super annoying.

# SOLUTION: Since readline parses LS_COLORS at initialization and never again
# after that, the trick is to set 'mi=00' in LS_COLORS, then do anything that
# causes readline to be initialized, and then set LS_COLORS back to its
# original value.  Alternatively we could just not put anything for missing
# files in LS_COLORS but I wanted figure out a way to have some coloring for
# missing files
#
# RELEVANT CODE FROM READLINE
# In http://git.savannah.gnu.org/cgit/bash.git/tree/lib/readline/:
# - In parse_colors.c:300 Function _rl_parse_colors() parses LS_COLORS
# - In readline.c:1322 Function readline_initialize_everything calls
#   _rl_parse_colors();
# - In readline.c:1183 Function rl_initialize() calls readline_initialize_everything()
#   only if rl_initialized == 0 then sets rl_initialized to 1 so that it
#   is never called again and does "other stuff".  Future calls to
#   rl_initialize() only do the "other stuff"
# - In realine.c:354 Function readline(), rl_initialize() is called everytime
#   but after the first time, it only does the "other stuff".
#
# IMPORTANT: This needs to be done before anything else causes the otherwise
# the initialization will already have happened with whatever LS_COLORS was at
# that time.  For example, fzf initialization does many 'bind x y' commands
# which initializes readline
################################################################################
set_ls_colors_for_readline_and_ls(){

    :
    # Set LS_COLORS however you like
    # eval "$(dircolors -b)"

    # # Initialize readline with those same LS_COLORS except for the 'mi' part
    local my_ls_colors="${LS_COLORS}"
    LS_COLORS="$(echo "${LS_COLORS}" | sed 's/mi=[0-9;]*/mi=00/')"
    bind -f ~/.inputrc # Anything that causes initialization of readline library

    # # Put back the 'mi' part in LS_COLORS
    # # We need the 'show-colored-stats' to be for BASH only in ~/.inputrc since
    # # the python interpreter will initialize readline in its process and will
    # # read LS_COLORS.  Anyway, we don't want show-colored-stats in Python so
    # # that is totally OK.
    LS_COLORS="${my_ls_colors}"
}

glcurl-project-job(){
    if [[ "$1" == -h ]] || (( $# != 2 )); then
        echo "${FUNCNAME[0]} PROJECT_ID JOB_ID"
        echo ""
        echo "Show subset of job information using jq"
        if [[ "$1" == -h ]] ; then
            return 0
        else
            echo "ERROR: Two arguments required"
            return 1
        fi
    fi
    resp="$(glcurl /projects/$1/jobs/$2)"
    if [[ "${resp}" != {\"id\"* ]] ; then
        jq <<< ${resp}
        return 1
    fi
    jq '{id,stage,name,web_url,ref,tag,pipeline:.pipeline|{id,web_url},user:.user|{id,name,location,organization},commit:.commit|{short_id,message,author_name}}' <<< "${resp}"
}


command_not_found_handle(){
    local pack=$HOME/.profile.d/interactive/pack/$1
    if [[ -f "${pack}" ]] ; then
        p.use $1
        unset -f command_not_found_handle
        "$@"
    else
        echo "bash: $1: command not found" >&2
        return 127
    fi
}



# I always forget whether it's SSMUSE_VERBOSE_XTRACE or SSMUSE_XTRACE_VERBOSE
# plus ssmuse-sh checks if the value is == 1, not empty vs non-empty which would
# be more standard.  Every time, it took me like 3 tries to get it so I made
# this function.
p.verbose_ssm(){
    export SSMUSE_XTRACE_VERBOSE=1
}
###################### KEEP THIS AT THE END ####################################
p.profile.main
unset -f p.profile.main
unset -f p.profile.main_interactive
