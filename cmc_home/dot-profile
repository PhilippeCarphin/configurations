#!/bin/bash

function dump-environment(){
    local envdump_dir=$HOME/envdumps
    mkdir -p ${envdump_dir}
    local envdump_file=$(mktemp env_dump_$(TZ=America/Toronto date +%Y-%m-%d_%H:%M:%S)_XXX.txt --tmpdir=${envdump_dir})
    echo "envdump_file = ${envdump_file}" >&2
    echo "\$0 = '$0'" >> ${envdump_file}
    echo "\$@ = '$@'" >> ${envdump_file}
    command env >> ${envdump_file}
}

function reminders(){
    echo "C-h does backward-word (.inputrc)"
    echo "C-l does forward-word (.inputrc)"
}

# dump-environment

if [[ $TERM == "dumb" ]] ; then
    source ~/.profile_officiel
    return
fi

#
# I want what this script does to be the first thing you see when opening it
# and to have no "naked" code inside the script except for that thing at the
# top and the call to main at the very end.
#
function p.profile.main(){
    export SSM_DEV=/home/ords/cmdd/cmds/nil000/ssm
    export STOW_DIR="$HOME/fs1"
    export PACKAGE_DIR="$STOW_DIR/Cellar"
    export GITLAB_RUNNER_SCIENCE_ORDSOUMET_KEEP_FILES='yas'
    export GONOSUMDB=gitlab.science.gc.ca
    export PATH="$STOW_DIR/bin:$HOME/bin:$HOME/.local/bin${PATH:+:$PATH}"
    GITLAB_ACCESS_TOKEN="$(cat ~/.ssh/gitlab-access-token)"
    export GITLAB_ACCESS_TOKEN
    PATH+=":$HOME/tools/go1.19.linux-amd64/bin"
    PATH+=":$HOME/tools/node-v16.13.1-linux-x64/bin"
    PATH+=":$HOME/tools/rust-1.69.0-x86_64-unknown-linux-gnu/bin"

    if [[ "$-" == *i* ]] ; then
        p.profile.main_interactive
    fi
}


function p.profile.main_interactive(){
    # p.check-processes
    # p.nice-completion
    # Remove that thing where it looks for Ubuntu packages if a command is not found
    # unset command_not_found_handle
    check-alert-file ~sici000/alert
    check-alert-file ~/alert

    eval "$(dircolors -b)"

    source "$HOME/.ssh/ssh_functions.sh"
    # source "$HOME/.funky-prompt.sh"
    source "$HOME/.powerline.sh"
    # Append to global history after every command.
    # .funky-prompt.sh sets PROMPT_COMMAND
    # so this next line must come AFTER sourcing ~/.funky-prompt.sh
    PROMPT_COMMAND="$PROMPT_COMMAND; history -a"
    maybe-source "$HOME/.gem-functions.sh"
    maybe-source "$HOME/.maestro-functions.sh"

    _source_dir "$HOME/.bash_completion.d"
    _source_dir "$HOME/fs1/etc/bash_completion.d"
    _source_dir "$HOME/fs1/etc/profile.d"


    alias ls='ls --color -h'
    alias grep='grep -n --color'
    alias tree='tree -C'
    alias rmb='rm -rf ../build/*'
    # From /etc/profile.d/which2.sh It makes which report what type reports but it only works on RHEL
    # alias which='(alias; declare -f) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot'

    export TZ=America/Toronto
    HISTSIZE=-1
    HISTFILESIZE="A non numeric value inhibits truncation"
    HISTIGNORE="rm -rf *"
    # A bit too whimsical
    # HISTTIMEFORMAT=$'\033[1;32m%y-%m-%d \033[1;33m%H\033[0m:\033[1;34m%M\033[0m:\033[1;31m%S\033[0m '
    HISTTIMEFORMAT=$'\033[1;32m%Y-%m-%d \033[1;33m%H:%M:%S\033[0m '
    GIT_CD_VERBOSE=yes

    # Merci Philippe Blain :D
    shopt -s direxpand

    if [[ "${PBS_ENVIRONMENT}" == PBS_INTERACTIVE ]] ; then
        printf "PBS_ENVIRONMENT detected, cd'ing to \$PBS_O_WORKDIR=\033[33m${PBS_O_WORKDIR}\033[0m\n"
        cd "${PBS_O_WORKDIR}" || return
    fi
    reminders

    # Restore completion since 
    # complete -o default source .
}


function maybe-source(){
    if [ -f "${1}" ] ; then
        source "$1"
    fi
}


function check-alert-file(){
    local alert_file="$1"
    if [ -e "${alert_file}" ] ; then
        printf "\033[1;31m Alert from %s\n" "${alert_file}" >&2
        cat "${alert_file}"
    fi
}

function maybe-load-ordenv(){
    if [ -e ~/.ordenv-mode ] || [ -e ~/.maestro-mode ] ; then
        p.ordenv
    fi
}

function maybe-load-maestro(){
    if [ -e ~/maestro-mode ] ; then
        p.use-maestro
    fi
}

lsl(){
    ls --color=always -la "$@" | less -R
}

lsg(){
    ls --color=always -la | grep "$@"
}

#
# Since I put my gitlab access token in an environment variable, and for
# troubleshooting I often dump my environment to a file, I don't want to
# have my gitlab access token visible to anyone who looks at that file
# and I don't want to have to remember to change that files permissions
#
dots(){
    sed 's/./‚óè/g' <<< "$1"
}

#
# - Change "GITLAB_ACCESS_TOKEN=<the-token>" to "GITLAB_ACCESS_TOKEN=<dots>"
#   only because I think it's cool and it took me two seconds to code.
# - Change lines "BASH_FUNC_thing(){ stuff" to "BASH_FUNC_thing(){ stuff [...] }"
# - Remove all lines starting with a space because they are part of multiline
#   values of those BASH_FUNC_thing
dump-env(){
    command env "$@" \
        | sed "s/^GITLAB_ACCESS_TOKEN=.*/GITLAB_ACCESS_TOKEN=$(dots "$GITLAB_ACCESS_TOKEN")/" \
        | sed 's/\(^BASH_FUNC.*\)/\1 \x1b[33m[...]\x1b[0m }/' \
        | command grep -v '^}$\|^ ' \
        | sort
}

# DONT USE: Leaving it here to remind myself that this is
# in fact not equivalent to putting thins in inputrc: by
# using this function instead of inputrc, I wasn't getting
# any colored-stats during my autocompletions.

# Each line is equivalent to putting the content of
# the single quotes in ~/.inputrc
function p.nice-completion(){
    bind 'set colored-stats on'
    bind 'set colored-completion-prefix on'
    bind 'set visible-stats on'
}

function p.set-menu-complete(){
    # I think these things can go in the ~/.inputrc file, I know that
    # make tab cycle through commands after listing
    bind '"\t":menu-complete'
    bind "set show-all-if-ambiguous on"
    bind "set completion-ignore-case on"
    bind "set menu-complete-display-prefix on"
}


function p.set-web-proxy(){
    # From ~sbf000/.profile.d/interactive/post
    # except that I he had https_proxy=http://  and HTTPS_PROXY=http://
    # and I did            https_proxy=https:// and HTTPS_PROXY=https://
    # EDIT: Turns out my extra 's' at the end was making
    # things not work.
    local p=http://webproxy.science.gc.ca:8888/
    export http_proxy=${p}
    export https_proxy=${p}
    export HTTP_PROXY=${p}
    export HTTPS_PROXY=${p}
}

function p.unset-web-proxy(){
    unset http_proxy
    unset https_proxy
    unset HTTP_PROXY
    unset HTTPS_PROXY
}

    p=http://webproxy.science.gc.ca:8888/
function _source_dir(){
    dir="$1"
    if ! [ -d "$1" ] ; then
        # No echo so this function can be called on non-existant dirs
        # echo "${FUNCNAME[0]} ERROR: \$1='$1' is not a directory" >&2
        return 1
    fi
    for f in $(command env -i ls $dir) ; do
        if ! source "$dir/$f" ; then
            echo "${FUNCNAME[0]} ERROR: sourcing '$dir/$f' returned non-zero" >&2
        fi
    done
}


function p.dqsubi(){
    if ! [ -e "$1" ] ; then
        echo "ERROR: File '$1' does not exist" >&2
        return 1
    fi

    if ! tempfile="$(mktemp qsubi-decorated-job-XXXXXXXX.sh)" ; then
        echo "ERROR: Could not create tempfile" >&2
        return 1
    fi

    # Job must have '#!/bin/bash' otherwise it "doesn't work"
    cat "$1" | decorate-script -cd -shebang >> "${tempfile}"

    chmod +x "${tempfile}"
    qsub -I -- "${tempfile}"
    rm "${tempfile}"
}

function p.pipeqsubi(){
    # This funciton shows that we can use the 'script' command to run 'qsubi -I'
    # when stdin is not a TTY.
    #
    # If we wanted to have shell script that would run something interactively
    # for us using qsub -I directly, it will complain that STDIN is not a tty 
    # and refuse to do its thing.
    if ! tempfile="$(mktemp qsubi-decorated-job-XXXXXXXX.sh)" ; then
        echo "ERROR: Could not create tempfile" >&2
        return 1
    fi

    decorate-script -cd -shebang >> "${tempfile}"

    chmod +x "${tempfile}"
    script -c "qsub -I -- \"${tempfile}\""
    # rm "${tempfile}"
}

function gitk(){
   command gitk --all "$@" &
}

function orgman(){
    pandoc --standalone -f org -t man $1 | /usr/bin/man -l -
}

function p.setup-intel(){
    if [[ "${PHIL_EC_ENV}" == *intel* ]] ; then
        return 0
    fi
    time {
        # source $(repos -get-dir ci-env)/latest/rhel-8-icelake-64/inteloneapi-2022.1.2.sh
        # source $(repos -get-dir ci-env)/latest/rhel-8-icelake-64/inteloneapi-2022.1.2.sh
        # source $(repos -get-dir ci-env)/latest/rhel-8-amd64-64/inteloneapi-2022.1.2.sh file doesn't exist
        source "$(repos -get-dir ci-env)/latest/rhel-8-amd-64/inteloneapi-2022.1.2.sh"
        export SSM_DEV=/home/ords/cmdd/cmds/nil000/ssm
        export PHIL_EC_ENV=intel${PHIL_EC_ENV:+|${PHIL_EC_ENV}}
        complete -o default source .
    }
}

function p.setup-gnu(){
    time {
        source "$(repos -get-dir ci-env)/latest/rhel-8-amd-64/gnu-9.3.0.sh"
        export PHIL_EC_ENV=gnu${PHIL_EC_ENV:+|${PHIL_EC_ENV}}
        complete -o default source .
    }
}

#
# This function looks really long but all it does is load ORDENV and only prints
# the output if there was an error.  It does this by redirecting the output
# to a tempfile and printing the file if the status after loading ordenv is
# non-zero.
#
# ORDENV reorders PATH elements and messes with the completion of 'source' and
# '.' so I put back my thing at the front of PATH and restore completion
# behavior for source and '.'.
function p.ordenv()
{
    local ORDENV_VERBOSE="yup"
    if [[ -z "${ORDENV_VERBOSE}" ]] ; then
        source ~/.profile_officiel
        return
    fi
    printf "\033[33m%s\033[0m\n" "Loading ordenv $(readlink ~/.profile_officiel)"
    #
    # Use a temporary file to capture output of a source command since
    # $(source a_file.sh) would lose the effect of sourcing the file.
    #
    # See https://stackoverflow.com/a/66832192/5795941 which confirms that
    # to do this we pretty much have to resort to using a temporary file.
    #
    local ordenv_output_file
    ordenv_output_file="$(mktemp "$HOME/.ordenv_output_file_XXXXXXXXXXX")"

    #
    # Source the official profile
    #
    {
        echo "On host : $HOSTNAME"
        echo "At date : $(date)"
        source ~/.profile_officiel
    } &> ${ordenv_output_file}
    local ordenv_status=$?

    #
    # Only show the captured output if an error happened during the
    # loading of ORDENV.  Otherwise, just print the last line which
    # should be the line showing the time elapsed during the loading
    # of ORDENV
    #
    if [[ "${ordenv_status}" != 0 ]] ; then
        printf "ERRORS occured during loading of ordenv\n" >&2
        cat "${ordenv_output_file}" >&2
    else
        printf "Sourcing of ORDENV successful\n" >&2
        tail -n 1 "${ordenv_output_file}" >&2
        rm -f "${ordenv_output_file}"
    fi

    #
    # Cleanup tempfile
    #

    #
    # Readjust the PATH.  I don't remember why I put this here.  Probably
    # because it prepends something which I would like to see come after
    # my own things in $HOME/fs1.
    #
    export PATH="$HOME/fs1/bin:${PATH}"

    #
    # Variable that is shown in my prompt string so that my PS1 can
    # show whether ORDENV is loaded or not.
    #
    export PHIL_EC_ENV="ORDENV${PHIL_EC_ENV:+|${PHIL_EC_ENV}}"

    # Loading ordenv messes up autocompletion on the source command
    complete -o default source .
}

function _p.require_ordenv()
{
    if [ -z "$ORDENV_SETUP" ] ; then
        p.ordenv 1>&2
    fi
}

function p.myjobs()
{
    (
        _p.require_ordenv
        jobst | grep "${USER}" -n
        exec 1>/dev/null
    )
}

function p.clearjobs()
{
    (
        _p.require_ordenv
        for jobid in $(jobst -u $USER | grep $USER | cut -d '|' -f 1) ; do
            while jobdel ${jobid} > /dev/null 2>&1
            do
                echo "Killing job '${jobid}'" >&2
                sleep 3
            done
            echo "" >&2
            echo "Job '${jobid}' successfully killed." >&2
        done
    )
}


function p.realpath(){
    local pyfunc="${FUNCNAME[0]##p.}"
    python3 -c "import os; print(os.path.${pyfunc}('$1'))"
}

function p.normpath(){
    local pyfunc="${FUNCNAME[0]##p.}"
    python3 -c "import os; print(os.path.${pyfunc}('$1'))"
}

function p.relpath(){
    if [[ "$1" == "" ]] ; then
        echo "${FUNCNAME[0]}: ERROR: Missing argument

USAGE: ${FUNCNAME[0]} PATH [START]" >&2
        return 1
    fi
    local pyfunc="${FUNCNAME[0]##p.}"
    python3 -c "import os; print(os.path.${pyfunc}('$1', start='$2'))"
}

function emacs-daemon(){
    echo "Starting detatched tmux session named 'emacs-daemon' on '$(hostname)'" >&2
    tmux new -s emacs-daemon -d
    echo "Sending keys 'emacs --fg-daemon' to session" >&2
    tmux send-keys -t emacs-daemon 'emacs --fg-daemon
'
}

function vim(){
    local vimpath
    case $(hostname) in
        ppp*) vimpath=$HOME/fs1/bin/vim ;;
        *)  vimpath=/usr/bin/vim ;;
    esac

    if [[ "$*" == "" ]] ; then
        VIMPATH=${vimpath} git_vim -p .
    else
        VIMPATH=${vimpath} git_vim -p "$@"
    fi
}

git_vim(){
    declare -a args
    #
    # This seems like it could be reusable behavior to enable many commands
    # to open paths starting with ':' as relative to the root of a git repo
    if ! __resolve_git_colons "$@" &>/dev/null ; then
        args=("$@")
    fi
    echo "Running command 'vim -p ${args[@]}'"
    if [[ -n "${VIMPATH}" ]] ; then
        ${VIMPATH} "${args[@]}"
    else
        command vim "${args[@]}"
    fi
}


# function vimf(){
#     local directory=$1
#     vim $(find ${directory} -type f)
# }
# 
# function cdwqwer(){
#     local program=$1
#     local full_path
#     if ! full_path=$(which ${program}) ; then
#         echo "Command 'which ${program}' failed.  Aborting"
#         return 1
#     fi
#     local directory=$(dirname ${full_path})
#     printf "\033[33mcd ${directory}\033[0m"
#     cd ${directory}
# }

function sshpwd(){
    # Replace things like /fs/homeu1/eccc/cmd/cmds/<rest>
    # with /home/<rest>
    local dir="$(echo $PWD | sed 's/\/fs\/homeu[12]\/[a-z]\+\/[a-z]\+\/[a-z]\+/\/home/')"
    ssh -t "$@" "cd $dir ; bash -l"
}

function p.use-maestro(){
    _p.require_ordenv
    . ssmuse-sh -d eccc/cmo/isst/maestro/1.8.4
}

function p.use-cmds-python(){
    # https://gitlab.science.gc.ca/hpc/hpcr_upgrade_2/wikis/python
    if [[ "${PHIL_EC_ENV}" == *CMDS-PY* ]] ; then
        return 0
    fi
    _p.require_ordenv
    . ssmuse-sh -p /fs/ssm/eccc/cmd/cmds/env/python/py39_2022.05.24_rhel-8-icelake-64
    export PHIL_EC_ENV="${PHIL_EC_ENV:+$PHIL_EC_ENV|}CMDS-PY"
}

function p.use-rpnpy(){
    . ssmuse-sh -x rpn/MIG/ENV/d/rpnpy/rpnpy_2.1.6
}

function p.reload-profile(){
    unset ORDENV_SETUP
    source ~/.profile
}

function p.ordenv-mode(){
    touch ~/.ordenv-mode
    printf "Activating ordenv mode\n" >&2
}

function p.normal-mode(){
    printf "Deactivating ordenv mode\n" >&2
    rm -f ~/.ordenv-mode
}

function cddrw(){
    local cmd=$1
    if ! which "${cmd}" 2>/dev/null ; then
        >&2 echo -e "Usage : ${FUNCNAME[0]} CMD

CMD must be a command"
        return 1
    fi
    local command_location
    command_location="$(dirname "$(readlink -f "$(which "${cmd}")")")"
    printf "\033[33mcd %s\033[0m\n" "${command_location}" >&2
    cd "$command_location" || return
}

function p.use-totalview(){
    _p.require_ordenv
    local ssmcmd=". ssmuse-sh -x main/opt/totalview/totalview-2018.0.5"
    printf "\033[33m%s\033[0m\n" "${ssmcmd}"
    $ssmcmd
}

function p.use-ddt(){
    _p.require_ordenv
    local ssmcmd=". ssmuse-sh -x main/opt/forge/21.1.3"
    printf "\033[33m%s\033[0m\n" "${ssmcmd}"
    $ssmcmd
}


function p.use-vscode(){
    _p.require_ordenv
    . ssmuse-sh -x cmd/cmds/apps/vscode/1.38
}

# Documentation and shortcut for debugging with debugpy and vscode.
function p.debugpy(){
    if [[ "$1" == [0-9]* ]] ; then
        local port=$1; shift
    fi
    local file=$1
    if [ -z $file ] ; then
        printf "USAGE: p.debugpy [PORT] FILE [ARGS ...]

The PORT argument is detected as a string of only digits.  Therefore this command doesn't
work if your filename is only digits but that would be weird.

Run the command and launch the corresponding configuration in VSCode.  It should look like
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    \"version\": \"0.2.0\",
    \"configurations\": [
        {
            \"name\": \"Attach\",
            \"type\": \"python\",
            \"request\": \"attach\",
            \"connect\": {
                \"host\": \"localhost\",
                \"port\": 5678
            },
            // With this setting set to false, the debugger will enter library
            // functions.  Otherwise, doing 'step into' while on a library
            // function makes us jump over the function, confusing the audience.
            \"justMyCode\": false
        }
    ]
}
\033[1;31mERROR\033[0m: No file specified\n"
        return 1
    fi
    port=${port:-5678}
    cmd='python3 -m debugpy --wait-for-client --listen $port "$@"'
    printf "Launching waiting debugger: \033[1;32m%s\033[0m\n" "$(eval echo $cmd)"
    eval $cmd

}

function p.org-tangle(){
    #
    # Note where the file appears in the command.  I tried to
    #     emacs --batch -l org -f org-babel-tangle "$@"
    # because it was simpler but it did not work giving
    #     wrong type argument: stringp, nil
    # so I think that the file has to be specified before doing
    # the -f thing.  Or rather, a filename has to have already
    # been read before -f is seen by the command parsing code.
    #
    local file=$1
    shift
    cmd='emacs --batch -l org --eval "(setq org-src-preserve-indentation t)" ${file} -f org-babel-tangle "$@"'
    printf "Emacs batch command : \033[1;32m%s\033[0m\n" "$(eval echo $cmd)"
    eval $cmd
}

################################################################################
# Remove from end of line.  This function was made because
# when doing org-babel-tangle in emacs on Windows, even if the
# file is a UNIX file with LF opened through TRAMP, when tangling
# the resulting file has CRLF line endings.  Another way is to use
# the above function p.org-tangle on the UNIX system.  If however
# the emacs on that system is not the right version or is
# missing some packages, then it may only be possible to tangle
# it correctly on the Windows machine's emacs.  In that case
# this function can be used on the file after.
################################################################################
function p.crlf-to-lf(){
    local file=$1
    cmd="sed 's/^M$//' \"\$@\""
    printf "sed command: \033[1;32m%s\033[0m\n" "${cmd}"
    sed 's/
$//' "$@"
}


################################################################################
# Case insensitive glob find
################################################################################
function p.igfind(){
    find . -iname "*$1*"
}

function p.vstm(){
    ~/my_scripts/vscode-tmux-session.sh
}

function p.clean-vstm(){
    rm -f ~/.vscode-tmux-sockets/*
}

function p.myprocs(){
    ps -F -u "$USER"
}

function p.tcheck(){
    local nb_tmux
    nb_tmux=$(pgrep -au "$USER" tmux | wc -l)
    local tmux_color=""
    if ((nb_tmux > 15)) ; then
        tmux_color="\033[1;31m"
    elif ((nb_tmux > 10)) ; then
        tmux_color="\033[1;33m"
    fi

    printf "${tmux_color}Number of tmux procs : %s\033[0m\n" "${nb_tmux}"
}

function p.pcheck(){
    local nb_procs
    nb_procs=$(ps -u "$USER" | wc -l)
    local proc_color=""
    if ((nb_procs > 200)) ; then
        proc_color="\033[1;31m"
    elif ((nb_procs > 150)) ; then
        proc_color="\033[1;33m"
    fi
    printf "${proc_color}Number of processes  : %s\033[0m\n" "${nb_procs}"
}

function p.check-processes(){
    p.pcheck
    p.tcheck
}

function p.unansi(){
    sed 's/\x1b\[[0-9;]*m//g' "$@"
}

function p.qsubi(){
    qsub -I -lselect=1:ncpus=72:mem=50gb "$@"
}

function p.quiet-make(){
    # Most PRN-SI projects have set(CMAKE_VERBOSE_MAKEFILE TRUE) which
    # means the makefiles verbose by default and require an explicit
    # 'VERBOSE=' (setting to nothing) to make them non-verbose
    PHIL_VERBOSE_MAKE=""
}

function p.verbose-make(){
    # Most PRN-SI projects have set(CMAKE_VERBOSE_MAKEFILE TRUE) which
    # means the makefiles verbose by default and require an explicit
    # 'VERBOSE=' (setting to nothing) to make them non-verbose
    PHIL_VERBOSE_MAKE=1
}


function make(){
    if ! on_compute_node ; then
        for arg in "$@" ; do
            if [[ "${arg}" == -j* ]] ; then
                echo "You are on host ${HOSTNAME} ... you should not use '-j'.  Use 'command make $*' to bypass this function if you are sure"
                return 1
            fi
        done
    fi
    command make VERBOSE=${PHIL_VERBOSE_MAKE} "$@"
}


function p.dusage(){
    du --max-depth=1 -h | sort -h
}

p.pgrep(){
    #  -f, --full
    #         The  pattern is normally only matched against the
    #         process name.  When -f is set, the  full  command
    #         line is used.
    #
    pgrep -u $USER -f "$@"
}

p.use-fstd2nc(){
    # Sebastien Fortier told me about a cool python package that can
    # read fstd (RPN standard files) in python that doesn't depend on
    # librmn.
    . ssmuse-sh -p eccc/crd/ccmr/EC-CAS/master/fstd2nc_0.20220204.3
}

p.ps(){
    # Note, 
    ps -f -u $USER --cols $(tput cols) | sort -k 8
}

p.use-thinlinc(){
    . ssmuse-sh -x main/opt/thinlinc/thinlinc_4.11.0
}

p.check_procs_pppn(){
    local pppn=${1}
    if ! echo ${pppn} | grep -P "(ppp5)|(ppp6)" &>/dev/null ; then
        echo "Argument 1 must be ppp5 or ppp6"
        return 1
    fi

    for node in ${pppn}login-001 ${pppn}login-002 ; do
        printf "\033[1;32mLogging in to $node\033[0m\n"
        ssh -t -J${pppn} ${node} bash -lic true
    done
}

p.check_procs_all(){
    for pppn in ppp5 ppp6 ; do
        printf "\033[1;35mChecking nodes on ${pppn}\033[0m\n"
        p.check_procs_pppn ${pppn}
    done
}

git_cd(){
    local dir repo_subdir
    local repo_subdir="${1##:}"
    if ! dir="$(git rev-parse --show-toplevel)/${repo_subdir}" ; then
        echo "${FUNCNAME[0]}: ERROR: cd ${1} see above"
        return 1
    fi

    if ! cd "$dir"; then
        echo "${FUNCNAME[0]}: ERROR: cd ${1} see above"
        return 1
    fi

    printf "\033[33mcd ${dir}\033[0m\n"
}

cd(){
    if [[ "${1}" == :* ]] ; then
        git_cd "${1}"
    else
        command cd "$@"
    fi
}

_cd_phil(){
    local IFS='
'
    local cur prev words cword;
    _init_completion || return;
    if [[ "${words[1]}" == :* ]] ; then
        # _complete_git_cd
        _complete_git_cd_with_colons
    else
        _cd
    fi
}


################################################################################
# Complete paths starting with ':' starting from the root of the current git
# repository.
################################################################################
_complete_git_cd(){
    # echo "======================================" >> ~/.log.txt
    COMPREPLY=()
    local IFS=$'\n'

    compopt -o filenames
    local cur prev words cword git_repo
    _init_completion || return;

    if ! git_repo="$(git rev-parse --show-toplevel 2>/dev/null)" ; then
        return 1
    fi

    # Complete 'cd :' to 'cd :/'.  This is important since otherwise, we
    # risk getting candidates from the parent directory of the git repo:
    # If we are in /home/phc001/repo but /home/phc001/repo_alternate exists,
    # then without this, compgen -d /home/phc001/repo will give those two
    # directories.
    if [[ "${cur}" == : ]] ; then
        COMPREPLY=("/")
        return
    fi

    # Because COMP_WORDBREAKS contains ':', when the command line is 'cd :',
    # the words array is ('cd' ':') in which case we do the above completion.
    # In every other case such as 'cd :/a', the words array is ('cd' ':' '/a')
    # If we wanted to keep the words as they are on the command line without
    # separating on colons, then we need to do as in _complete_git_cd_with_colons
    # and use __rassemble_comp_words_by_ref and __ltrim_colon_completions
    if [[ "${prev}" != : ]] ; then
        return
    fi

    full_cur="${git_repo}${cur#:}"

    local i=0
    local candidates=( $(compgen -d -- ${full_cur}) )
    for full_path in "${candidates[@]}" ; do
        relative_path="${full_path##${top}}/"
        COMPREPLY[i++]="${relative_path}"
    done
}

################################################################################
# Complete paths starting with ':' starting from the root of the current git
# repository.  This is an alternate version that I made to figure out how to
# use deal with completing words that contain colons.  The first one is easier
# since we just deal with the part after the colon separately and return
# candidates for the part that comes after the colon.  This one is not so
# hard either.
################################################################################
_complete_git_cd_with_colons(){
    local top IFS='
'
    echo "======================================" >> ~/.log.txt
    compopt -o filenames
    if ! top="$(git rev-parse --show-toplevel)" ; then
        return
    fi


    # Local is very important otherwise full_words and full_cword would
    # become global variables that would grow every time __reassemble_comp_words_by_ref
    # is called.  I could also do '_init_completion -n :'.  Either way the call
    # to __ltrim_colon_completion is required at the end.
    local full_words full_cword;
    __reassemble_comp_words_by_ref ':' full_words full_cword
    # echo "full_words = ${full_words[@]}" >> ~/.log.txt

    local cur=${full_words[full_cword]}


    if [[ "${cur}" == ":" ]] ; then
        COMPREPLY=(":/")
        __ltrim_colon_completions ':'
        return
    fi

    if ! [[ "${cur}" == :* ]] ; then
        return
    fi

    full_cur=${top}${cur#:}
    candidates=($(compgen -d -- ${full_cur}))
    local i=0
    for full_path in "${candidates[@]}" ; do
        # echo "d = ${d}" >> ~/.log.txt
        # echo "s = ${s}" >> ~/.log.txt
        relative_path=:${d##${top}}/
        COMPREPLY[i++]=${relative_path}
    done
    __ltrim_colon_completions ':'

}

complete -o nospace -F _cd_phil cd


################################################################################
# Acquire compute node for building and running GEM (or anything else)
################################################################################
function p.qsubi(){
    qsub -I -lselect=1:ncpus=72:mem=50gb "$@"
}


function vimf(){
    local dir=${1-.}
    vim $(find $dir -type f)
}

function vimw(){
    local cmd=$1
    if [[ -z "${cmd}" ]] ; then
        echo "${FUNCNAME[0]}: ERROR: Please provide a command"
        return 1
    fi

    local cmd_path
    if ! cmd_path=$(which ${cmd}) ; then
        echo "${FUNCNAME[0]}: ERROR: Command not found using which"
        return 1
    fi
    vim ${cmd_path}
}

function _errprint(){
    printf "${FUNCNAME[1]}: \033[1;31mERROR\033[0m: $*\n" >&2
}

function p.view_listing(){
    local compressed_listing=$1
    if ! [[ -f "${compressed_listing}" ]] ; then
        # printf "${FUNCNAME[0]}: \033[1;31mERROR\033[0m: Listing '${compressed_listing}' does not exist\n"
        _errprint "Listing '${compressed_listing}' does not exist"
        return 1
    fi
    # Assume that mktemp always succeeds
    local tempfile=$(mktemp uncompressed_listing_XXXXXX.sh)
    gunzip -c ${compressed_listing} > ${tempfile}
    vim ${tempfile}
    if ! rm ${tempfile} ; then
        _errprint "Could not remove '${tempfile}'"
    fi
}





p.profile.main

unset -f p.profile.main
unset -f p.profile.main_interactive
