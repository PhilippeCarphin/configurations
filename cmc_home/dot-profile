#!/bin/bash

p.error(){
    printf "${FUNCNAME[1]}: \033[1;31mERROR\033[0m: $*\n" >&2
}

function p.profile.main(){
    export EDITOR=/usr/bin/vim
    export LOG_LEVEL=ERROR # For r.load
    export CMAKE_EXPORT_COMPILE_COMMANDS=TRUE
    export TZ=America/Toronto
    export LANG=en_US.UTF-8
    export SSM_DEV=/home/ords/cmdd/cmds/nil000/ssm
    export GITLAB_RUNNER_SCIENCE_ORDSOUMET_KEEP_FILES='yas'
    export GONOSUMDB=gitlab.science.gc.ca
    export PATH="$HOME/bin:$HOME/.local/bin${PATH:+:$PATH}:$HOME/tools/go/bin:${HOME}/tools/rust-1.75/bin"
    # export EDITOR=/usr/bin/vim
    . ssmuse-sh -x /fs/ssm/hpco/exp/ssmuse/ssmuse-1.13-beta2
    configure_fs1_env
    configure_spack
    configure_vscode_server_environment
    if [[ "$-" == *i* ]] ; then
        p.profile.main_interactive
    fi
}

function p.profile.main_interactive(){
    export PYTHONSTARTUP=~/.pyrc
    export PACK_DIR=${HOME}/.profile.d/interactive/pack
    set_ls_colors_for_readline_and_ls

    source "$HOME/Repositories/github.com/philippecarphin/bash-powerline/powerline.sh"
    PROMPT_COMMAND="$PROMPT_COMMAND; history -a"
    source "$HOME/.git-completion.bash"
    source "$HOME/.ssh/ssh_functions.sh"
    source "$HOME/.philconfig/shell_lib/x.use"
    source "$HOME/.philconfig/shell_lib/functions.sh"
    source "$HOME/.philconfig/shell_lib/view-rev-file.sh"
    source "$HOME/A_CLASSER/env-diff/env-diff-cmd.bash"
    FZF_COMPLETION_OPT="--preview 'bat --color=always {}'"
    source ~/.fzf.bash
    _source_dir "$HOME/.bash_completion.d"

    alias ls='ls --color -h'
    alias grep='grep -n --color'
    alias tree='tree -C'
    alias rmb='rm -rf ../build/*'
    alias rg='rg --no-heading --color=auto'
    alias gdb='~phb001/.local_rhel-8-icelake-64/bin/gdb -q -tui'
    alias gdbserver='~phb001/.local_rhel-8-icelake-64/bin/gdbserver'
    alias diff='diff -u --color'
    alias :wqa='exit 0'
    alias :q='exit 0'
    alias :qa='exit 0'
    alias :wq='exit 0'
    alias :cq='exit 1'
    alias cd='wrap_command_colon_paths cd'
    complete -F __complete_git_colon_dirs cd
    alias git=git-enforce-rules-of-philippes
    complete -o default -o nospace -o filenames -F _DottableCompletion source .
    shopt -s direxpand # Merci Philippe Blain :D
    check-alert-file ~sici000/alert
    check-alert-file ~/alert
    maybe_cd_to_pbs_o_workdir
    configure_history
    configure_vim
}

configure_fs1_env(){
    # See code of __load_completion from /usr/share/bash-completion/bash_completion ...
    # It searches an array of directories that starts out as
    # Since I don't define BASH_COMPLETION_USER_DIR and XDG_DATA_HOME
    # is also not defined, dirs=(${HOME}/.local/share/bash-completion/completions).
    # After that it does
    #     dirs=(${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions)
    #     # Equivalently: dirs is defined following this logic:
    #     # if[[ -z ${BASH_COMPLETION_USER_DIR} ]] ; then
    #     #     dirs=(${BASH_COMPLETION_USER_DIR}/completions)
    #     # else
    #     #     if [[ -n ${XDG_DATA_HOME} ]] ; then
    #     #         dirs=(${XDG_DATA_HOME}/bash-completion/completions)
    #     #     else
    #     #         dirs=($HOME/.local/share/bash-completion/completions)
    #     #     fi
    #     # fi
    #
    #     # Add '$d/bash-completion/completions' for each dir in XDG_DATA_DIRS and /usr/local/share and /usr/share
    #     for dir in ${XDG_DATA_DIRS:-/usr/local/share:/usr/share};
    #         dirs+=($dir/bash-completion/completions);
    #     done
    #
    export STOW_DIR="$HOME/fs1"
    XDG_DATA_DIRS=${XDG_DATA_DIRS:+${XDG_DATA_DIRS}:}${STOW_DIR}/etc
    export PACKAGE_DIR="$STOW_DIR/Cellar"
    export LD_LIBRARY_PATH="${STOW_DIR}/lib:${STOW_DIR}/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}"
    export PATH=${STOW_DIR}/bin${PATH:+:${PATH}}
    _source_dir "$HOME/fs1/etc/bash_completion.d"
    _source_dir "$HOME/fs1/etc/profile.d"
}

maybe_cd_to_pbs_o_workdir(){
    if [[ "${PBS_ENVIRONMENT}" == PBS_INTERACTIVE ]] ; then
        printf "PBS_ENVIRONMENT detected, cd'ing to \$PBS_O_WORKDIR=${PBS_O_WORKDIR}\n" >&2
        if ! cd "${PBS_O_WORKDIR}" ; then
            p.error "Could not CD to '$PBS_O_WORKDIR', perhaps it is not on a network filesystem"
        fi
        echo "${PBS_JOBID}" > ~/.ssh/current_job
        echo "JOBID ${PBS_JOBID} written in ~/.ssh/current_job" >&2
    fi
}


function maybe-source(){
    if [ -f "${1}" ] ; then
        source "$1"
    fi
}

################################################################################
# Certain things about our environment setup don't jive well with vscode-server
# so we override them for that case.
# - TMPDIR: contains the PID of the process that loaded ordenv. Otherwise:
#   - parent : lauches a child
#   - child : has TMPDIR which contains PID of parent
#   - parent : detaches child and exits, causing r.cleanup_tmpdir to delete
#              TMPDIR
#   - child : has a TMPDIR which does not exist.
# 
################################################################################
configure_vscode_server_environment(){
    # Dump environment to file at very beginning to see what the env looks
    # like when vscode server logs in.
    #
    # env -0 | sort -z | tr '\0' '\n' > ~/env_$(date +%Y-%m-%d_%H.%M.%S)
    #
    if [[ -v VSCODE_AGENT_FOLDER ]] ; then
        export GO111MODULES=off
        export TMPDIR=/tmp/$USER/vscode-server
        mkdir -p ${TMPDIR}
    fi
}

configure_spack(){
    export SPACK_SKIP_MODULES=y
    if [[ -n "${SPACK_SKIP_MODULES}" ]] ; then echo "WARNING: SPACK_SKIP_MODULES is set" >&2 ; fi
    . $(repos -get-dir spack)/share/spack/setup-env.sh
}

function check-alert-file(){
    local alert_file="$1"
    if [ -e "${alert_file}" ] ; then
        printf "\033[1;31m Alert from %s\n" "${alert_file}" >&2
        cat "${alert_file}"
    fi
}

function configure_history(){
    # https://stackoverflow.com/a/19533853/5795941
    # Other contexts may truncate the history, namely some people have said that
    # history may get truncated at bash startup before these two settings have
    # taken effect.  Therefore, we set the history to unlimited size, and only
    # after doing that we set the history file to a different file.
    HISTSIZE=-1
    HISTFILESIZE=-1
    HISTIGNORE="rm -rf *"
    HISTFILE=~/.eternal_bash_history
    HISTTIMEFORMAT=$'\033[1;32m%Y-%m-%d \033[1;33m%H:%M:%S\033[0m '
}


function _source_dir(){
    local dir="$1"
    if ! [ -d "$1" ] ; then
        return 1
    fi
    local f
    for f in $(command env -i ls $dir) ; do
        if ! ( [[ "$f" = *.sh ]] || [[ "$f" = *.bash ]] ) ; then
            continue
        fi
        if ! source "$dir/$f" ; then
            p.error "sourcing '$dir/$f' returned non-zero"
        fi
    done
}

function configure_vim(){
    complete -o default -F __complete_git_colon_paths vim
    function vim()(
        if [[ $(hostname) != ppp* ]] ; then
            /usr/bin/vim -p "$@"
            return
        fi
        local IFS=:
        for d in ${CMAKE_PREFIX_PATH} ; do
            C_INCLUDE_PATH=${d}/include${C_INCLUDE_PATH:+:${C_INCLUDE_PATH}}
        done
        while IFS='=' read -r -d $'\0' k v ; do
            if [[ "${k}" = *_DIR ]] ; then
                C_INCLUDE_PATH=${v}/include${C_INCLUDE_PATH:+:${C_INCLUDE_PATH}}
            fi
        done < <(env -0)
        export C_INCLUDE_PATH
        # echo "C_INCLUDE_PATH=${C_INCLUDE_PATH}"
        wrap_command_colon_paths command vim -p "$@"
    )
}


################################################################################
# PROBLEM: If you have 'set colored-stats on' in your ~/.inputrc, readline will
# color completion candidates according to LS_COLORS.  Therefore it will color
# anything that is not a file (program options) according to the as 'missing
# files' which if you have 'mi=01;05;37;49' in your LS_COLORS is bold blinking
# bright white on red background which is super annoying.

# SOLUTION: Since readline parses LS_COLORS at initialization and never again
# after that, the trick is to set 'mi=00' in LS_COLORS, then do anything that
# causes readline to be initialized, and then set LS_COLORS back to its
# original value.  Alternatively we could just not put anything for missing
# files in LS_COLORS but I wanted figure out a way to have some coloring for
# missing files
#
# In http://git.savannah.gnu.org/cgit/bash.git/tree/lib/readline/:
# - In parse_colors.c:300 Function _rl_parse_colors() parses LS_COLORS
# - In readline.c:1322 Function readline_initialize_everything
# - In readline.c:1183 Function rl_initialize() calls readline_initialize_everything()
#   only if rl_initialized == 0 then sets rl_initialized to 1 so that it
#   is never called again and does "other stuff".  Future calls to
#   readline_initialize_everything() only do the "other stuff"
# - In realine.c:354 Function readline(), rl_initialize() is called everytime
#   but after the first time, it only does the "other stuff".
#
# IMPORTANT: This needs to be done before anything else causes the otherwise
# the initialization will already have happened with whatever LS_COLORS was at
# that time.  For example, fzf initialization does many 'bind x y' commands
# which initializes readline
################################################################################
set_ls_colors_for_readline_and_ls(){

    :
    # Set LS_COLORS however you like
    eval "$(dircolors)"

    # # Initialize readline with those same LS_COLORS except for the 'mi' part
    # local my_ls_colors="${LS_COLORS}"
    # LS_COLORS="$(echo "${LS_COLORS}" | sed 's/mi=[0-9;]*/mi=00/')"
    # bind -f ~/.inputrc # Anything that causes initialization of readline library

    # # Put back the 'mi' part in LS_COLORS
    # # We need the 'show-colored-stats' to be for BASH only in ~/.inputrc since
    # # the python interpreter will initialize readline in its process and will
    # # read LS_COLORS.  Anyway, we don't want show-colored-stats in Python so
    # # that is totally OK.
    # LS_COLORS="${my_ls_colors}"
}


###################### KEEP THIS AT THE END ####################################
p.profile.main
unset -f p.profile.main
unset -f p.profile.main_interactive
