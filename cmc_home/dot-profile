#!/bin/bash

p.error(){
    printf "${FUNCNAME[1]}: \033[1;31mERROR\033[0m: $*\n" >&2
}

#
# I want what this script does to be the first thing you see when opening it
# and to have no "naked" code inside the script except for that thing at the
# top and the call to main at the very end.
#

function p.profile.main(){
    _set_rload_log_level
    export TZ=America/Toronto
    export LANG=en_US.UTF-8
    export SSM_DEV=/home/ords/cmdd/cmds/nil000/ssm
    export STOW_DIR="$HOME/fs1"
    export PACKAGE_DIR="$STOW_DIR/Cellar"
    export GITLAB_RUNNER_SCIENCE_ORDSOUMET_KEEP_FILES='yas'
    export GONOSUMDB=gitlab.science.gc.ca
    export PATH="$STOW_DIR/bin:$HOME/bin:$HOME/.local/bin${PATH:+:$PATH}"
    export GITLAB_ACCESS_TOKEN="$(cat ~/.ssh/gitlab-access-token)"
    export EDITOR=/usr/bin/vim
    PATH+=":$HOME/tools/go1.19.linux-amd64/bin"
    PATH+=":$HOME/tools/node-v16.13.1-linux-x64/bin"
    # PATH+=":$HOME/tools/rust-1.69.0-x86_64-unknown-linux-gnu/bin"
    PATH+=":/home/phc001/tools/rust-1.68.0-x86_64-unknown-linux-gnu/install-dir/bin"
    . ssmuse-sh -x /fs/ssm/hpco/exp/ssm/ssm-12.0-beta1 \
                -x /fs/ssm/hpco/exp/ssmuse/ssmuse-1.13-beta2
    if [[ "$-" == *i* ]] ; then
        p.profile.main_interactive
    fi
}

function p.profile.main_interactive(){
    # p.check-processes
    # p.nice-completion
    # Remove that thing where it looks for Ubuntu packages if a command is not found
    # unset command_not_found_handle
    export PYTHONSTARTUP=~/.pyrc
    export PACK_DIR=${HOME}/.profile.d/interactive/pack

    # See code of __load_completion from /usr/share/bash-completion/bash_completion ...
    # It searches an array of directories that starts out as
    # dirs=(${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions)
    # Since I don't define BASH_COMPLETION_USER_DIR and XDG_DATA_HOME
    # is also not defined, dirs=(${HOME}/.local/share/bash-completion/completions).
    # After that it does
    #     for dir in ${XDG_DATA_DIRS:-/usr/local/share:/usr/share};
    #         dirs+=($dir/bash-completion/completions);
    XDG_DATA_DIRS=${XDG_DATA_DIRS:+${XDG_DATA_DIRS}:}${HOME}/fs1/etc
    check-alert-file ~sici000/alert
    check-alert-file ~/alert

    set_ls_colors_for_readline_and_ls

    source "$HOME/.ssh/ssh_functions.sh"
    # source "$HOME/.funky-prompt.sh"
    source "$HOME/.philconfig/shell_lib/powerline.sh"
    source "$HOME/.git-completion.bash"
    source ~/.fzf.bash
    FZF_COMPLETION_OPT="--preview 'bat --color=always {}'"
    SOURCE_COMPLETE_EXCLUDE_EXECUTABLE=""
    SOURCE_COMPLETE_ONLY_TEXT_FILES="yes"
    GIT_CD_VERBOSE=yes
    source $HOME/.philconfig/shell_lib/impersonate.sh
    # Append to global history after every command.
    # .funky-prompt.sh sets PROMPT_COMMAND
    # so this next line must come AFTER sourcing ~/.funky-prompt.sh
    PROMPT_COMMAND="$PROMPT_COMMAND; history -a"
    # Replaced by single files in ~/bin
    # maybe-source "$HOME/.philconfig/shell_lib/gem-functions.sh"
    maybe-source "$HOME/.philconfig/shell_lib/maestro-functions.sh"

    # _source_dir "$HOME/.bash_completion.d"
    _source_dir "$HOME/fs1/etc/bash_completion.d"
    _source_dir "$HOME/fs1/etc/profile.d"

    alias print_args='__print_args "$@"'
    alias ls='ls --color -h'
    alias grep='grep -n --color'
    alias tree='tree -C'
    alias rmb='rm -rf ../build/*'
    # From /etc/profile.d/which2.sh It makes which report what type reports but it only works on RHEL
    # alias which='(alias; declare -f) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot'

    HISTSIZE=-1
    HISTFILESIZE="A non numeric value inhibits truncation"
    HISTIGNORE="rm -rf *"
    # A bit too whimsical
    # HISTTIMEFORMAT=$'\033[1;32m%y-%m-%d \033[1;33m%H\033[0m:\033[1;34m%M\033[0m:\033[1;31m%S\033[0m '
    HISTTIMEFORMAT=$'\033[1;32m%Y-%m-%d \033[1;33m%H:%M:%S\033[0m '

    # Merci Philippe Blain :D
    shopt -s direxpand

    if [[ "${PBS_ENVIRONMENT}" == PBS_INTERACTIVE ]] ; then
        printf "PBS_ENVIRONMENT detected, cd'ing to \$PBS_O_WORKDIR=${PBS_O_WORKDIR}\n" >&2
        if ! cd "${PBS_O_WORKDIR}" ; then
            p.error "Could not CD to '$PBS_O_WORKDIR', perhaps it is not on a network filesystem"
        fi
        echo "${PBS_JOBID}" > ~/.ssh/current_job
        echo "JOBID ${PBS_JOBID} written in ~/.ssh/current_job" >&2
    fi

    fix-source-complete
    reminders

    # Cd
    # alias cd=__cd_or_git_cd
    # complete -o nospace -F _cd_or_git_cd cd
    alias cd='wrap_command_colon_paths cd'
    complete -o default -F __complete_git_colon_dirs cd

    # ls
    alias ls='wrap_command_colon_paths ls --color'
    complete -o default -F __complete_git_colon_paths ls


    configure_vim
}


function maybe-source(){
    if [ -f "${1}" ] ; then
        source "$1"
    fi
}


function check-alert-file(){
    local alert_file="$1"
    if [ -e "${alert_file}" ] ; then
        printf "\033[1;31m Alert from %s\n" "${alert_file}" >&2
        cat "${alert_file}"
    fi
}

function maybe-load-ordenv(){
    if [ -e ~/.ordenv-mode ] || [ -e ~/.maestro-mode ] ; then
        p.ordenv
    fi
}

function maybe-load-maestro(){
    if [ -e ~/maestro-mode ] ; then
        p.use-maestro
    fi
}

lsl(){
    ls --color=always -la "$@" | less -R
}

lsg(){
    ls --color=always -la | grep "$@"
}

#
# Since I put my gitlab access token in an environment variable, and for
# troubleshooting I often dump my environment to a file, I don't want to
# have my gitlab access token visible to anyone who looks at that file
# and I don't want to have to remember to change that files permissions
#
dots(){
    sed 's/./‚óè/g' <<< "$1"
}

#
# - Change "GITLAB_ACCESS_TOKEN=<the-token>" to "GITLAB_ACCESS_TOKEN=<dots>"
#   only because I think it's cool and it took me two seconds to code.
# - Change lines "BASH_FUNC_thing(){ stuff" to "BASH_FUNC_thing(){ stuff [...] }"
# - Remove all lines starting with a space because they are part of multiline
#   values of those BASH_FUNC_thing
dump-env(){
    command env "$@" \
        | sed "s/^GITLAB_ACCESS_TOKEN=.*/GITLAB_ACCESS_TOKEN=$(dots "$GITLAB_ACCESS_TOKEN")/" \
        | sed 's/\(^BASH_FUNC.*\)/\1 \x1b[33m[...]\x1b[0m }/' \
        | command grep -v '^}$\|^ ' \
        | sort
}

# DONT USE: Leaving it here to remind myself that this is
# in fact not equivalent to putting thins in inputrc: by
# using this function instead of inputrc, I wasn't getting
# any colored-stats during my autocompletions.

# Each line is equivalent to putting the content of
# the single quotes in ~/.inputrc
function p.nice-completion(){
    bind 'set colored-stats on'
    bind 'set colored-completion-prefix on'
    bind 'set visible-stats on'
}

function p.set-menu-complete(){
    # I think these things can go in the ~/.inputrc file, I know that
    # make tab cycle through commands after listing
    bind '"\t":menu-complete'
    bind "set show-all-if-ambiguous on"
    bind "set completion-ignore-case on"
    bind "set menu-complete-display-prefix on"
}


function p.set-web-proxy(){
    # From ~sbf000/.profile.d/interactive/post
    # except that I he had https_proxy=http://  and HTTPS_PROXY=http://
    # and I did            https_proxy=https:// and HTTPS_PROXY=https://
    # EDIT: Turns out my extra 's' at the end was making
    # things not work.
    local p=http://webproxy.science.gc.ca:8888/
    export http_proxy=${p}
    export https_proxy=${p}
    export HTTP_PROXY=${p}
    export HTTPS_PROXY=${p}
}

function p.unset-web-proxy(){
    unset http_proxy
    unset https_proxy
    unset HTTP_PROXY
    unset HTTPS_PROXY
}

function _source_dir(){
    local dir="$1"
    if ! [ -d "$1" ] ; then
        # No echo so this function can be called on non-existant dirs
        # p.error "\$1='$1' is not a directory"
        return 1
    fi
    local f
    for f in $(command env -i ls $dir) ; do
        if ! source "$dir/$f" ; then
            p.error "sourcing '$dir/$f' returned non-zero"

        fi
    done
}


function p.dqsubi(){
    if ! [ -e "$1" ] ; then
        p.error "File '$1' does not exist"
        return 1
    fi

    if ! tempfile="$(mktemp qsubi-decorated-job-XXXXXXXX.sh)" ; then
        p.error "Could not create tempfile"
        return 1
    fi

    # Job must have '#!/bin/bash' otherwise it "doesn't work"
    cat "$1" | decorate-script -cd -shebang >> "${tempfile}"

    chmod +x "${tempfile}"
    qsub -I -- "${tempfile}"
    rm "${tempfile}"
}

function p.pipeqsubi(){
    # This funciton shows that we can use the 'script' command to run 'qsubi -I'
    # when stdin is not a TTY.
    #
    # If we wanted to have shell script that would run something interactively
    # for us using qsub -I directly, it will complain that STDIN is not a tty 
    # and refuse to do its thing.
    if ! tempfile="$(mktemp qsubi-decorated-job-XXXXXXXX.sh)" ; then
        p.error "Could not create tempfile"
        return 1
    fi

    decorate-script -cd -shebang >> "${tempfile}"

    chmod +x "${tempfile}"
    script -c "qsub -I -- \"${tempfile}\""
    # rm "${tempfile}"
}

function gitk(){
   command gitk --all "$@" &
}

function orgman(){
    pandoc --standalone -f org -t man $1 | /usr/bin/man -l -
}

function p.setup-gnu(){
    time {
        source "$(repos -get-dir ci-env)/latest/rhel-8-amd-64/gnu-9.3.0.sh"
        export PHIL_EC_ENV=gnu${PHIL_EC_ENV:+|${PHIL_EC_ENV}}
        complete -o default source .
    }
}

function _p.require_ordenv()
{
    if [ -z "$ORDENV_SETUP" ] ; then
        p.ordenv 1>&2
    fi
}

function p.myjobs()
{
    (
        _p.require_ordenv
        jobst | grep "${USER}" -n
        exec 1>/dev/null
    )
}

function p.clearjobs()
{
    (
        _p.require_ordenv
        for jobid in $(jobst -u $USER | grep $USER | cut -d '|' -f 1) ; do
            while jobdel ${jobid} > /dev/null 2>&1
            do
                echo "Killing job '${jobid}'" >&2
                sleep 3
            done
            echo "" >&2
            echo "Job '${jobid}' successfully killed." >&2
        done
    )
}


function p.realpath(){
    local pyfunc="${FUNCNAME[0]##p.}"
    python3 -c "import os; print(os.path.${pyfunc}('$1'))"
}

function p.normpath(){
    local pyfunc="${FUNCNAME[0]##p.}"
    python3 -c "import os; print(os.path.${pyfunc}('$1'))"
}

function p.relpath(){
    if [[ "$1" == "" ]] ; then
        echo "${FUNCNAME[0]}: ERROR: Missing argument

USAGE: ${FUNCNAME[0]} PATH [START]" >&2
        return 1
    fi
    local pyfunc="${FUNCNAME[0]##p.}"
    python3 -c "import os; print(os.path.${pyfunc}('$1', start='$2'))"
}

function emacs-daemon(){
    echo "Starting detatched tmux session named 'emacs-daemon' on '$(hostname)'" >&2
    tmux new -s emacs-daemon -d
    echo "Sending keys 'emacs --fg-daemon' to session" >&2
    tmux send-keys -t emacs-daemon 'emacs --fg-daemon
'
}

function vimf(){
    local directory=$1
    vim -p $(find ${directory} -type f)
}


function sshpwd(){
    # Replace things like /fs/homeu1/eccc/cmd/cmds/<rest>
    # with /home/<rest>
    local dir="$(echo $PWD | sed 's/\/fs\/homeu[12]\/[a-z]\+\/[a-z]\+\/[a-z]\+/\/home/')"
    ssh -t "$@" "cd $dir ; bash -l"
}

function cddrw(){
    local cmd=$1
    if ! which "${cmd}" 2>/dev/null ; then
        >&2 echo -e "Usage : ${FUNCNAME[0]} CMD

CMD must be a command"
        return 1
    fi
    local command_location
    command_location="$(dirname "$(readlink -f "$(which "${cmd}")")")"
    printf "\033[33mcd %s\033[0m\n" "${command_location}" >&2
    cd "$command_location" || return
}

function cddw(){
    local cmd=$1
    if ! which "${cmd}" 2>/dev/null ; then
        >&2 echo -e "Usage : ${FUNCNAME[0]} CMD

CMD must be a command"
        return 1
    fi
    local command_location
    command_location="$(dirname "$(which "${cmd}")")"
    printf "\033[33mcd %s\033[0m\n" "${command_location}" >&2
    cd "$command_location" || return
}

function cdd(){
    local filepath=$1
    if [[ -d ${filepath} ]] ; then
        printf "${FUNCNAME[0]}: Warning: argument '${filepath}' is a directory.  Perhaps use cd or cdr\n" >&2
    fi

    local dir
    if ! dir=$(dirname ${filepath}) ; then
        p.error "Could not get dirname for '${link_target}'"
        return 1
    fi

    builtin cd ${dir}
}

function cddr(){
    local filepath=$1
    if [[ -d ${filepath} ]] ; then
        printf "${FUNCNAME[0]}: Warning: argument '${filepath}' is a directory.  Perhaps use cd or cdr\n" >&2
    fi
    local link_target
    if ! link_target=$(readlink ${filepath}) ; then
        p.error "Could not follow link '${filepath}'"
        return 1
    fi

    local dir
    if ! dir=$(dirname ${link_target}) ; then
        p.error "Could not get dirname for '${link_target}'"
        return 1
    fi

    builtin cd ${dir}
}


# Documentation and shortcut for debugging with debugpy and vscode.
function p.debugpy(){
    if [[ "$1" == [0-9]* ]] ; then
        local port=$1; shift
    fi
    local file=$1
    if [ -z $file ] ; then
        printf "USAGE: p.debugpy [PORT] FILE [ARGS ...]

The PORT argument is detected as a string of only digits.  Therefore this command doesn't
work if your filename is only digits but that would be weird.

Run the command and launch the corresponding configuration in VSCode.  It should look like
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    \"version\": \"0.2.0\",
    \"configurations\": [
        {
            \"name\": \"Attach\",
            \"type\": \"python\",
            \"request\": \"attach\",
            \"connect\": {
                \"host\": \"localhost\",
                \"port\": 5678
            },
            // With this setting set to false, the debugger will enter library
            // functions.  Otherwise, doing 'step into' while on a library
            // function makes us jump over the function, confusing the audience.
            \"justMyCode\": false
        }
    ]
}
\033[1;31mERROR\033[0m: No file specified\n"
        return 1
    fi
    port=${port:-5678}
    cmd='python3 -m debugpy --wait-for-client --listen $port "$@"'
    printf "Launching waiting debugger: \033[1;32m%s\033[0m\n" "$(eval echo $cmd)"
    eval $cmd

}

function p.org-tangle(){
    #
    # Note where the file appears in the command.   I  tried  to
    #     emacs --batch -l org -f org-babel-tangle "$@"
    # because  it  was  simpler  but  it  did  not  work  giving
    #     wrong type argument: stringp, nil
    # so I think that the file has to be specified before  doing
    # # the -f thing.  Or rather, a filename has to have already
    # # been read before -f is seen by the command parsing code.
    #
    # The manpage for emacs says that '-l', '-f',  '--eval'  are
    # Lisp-oriented, "these options are processed in  the  order
    # encountered".
    #
    # It does not say  that  for  the  file  to  open  but  from
    # experimentation, that's what I've seen
    #
    local file=$1
    shift
    cmd='emacs --batch -l org --eval "(setq org-src-preserve-indentation t)" ${file} -f org-babel-tangle "$@"'
    printf "Emacs batch command : \033[1;32m%s\033[0m\n" "$(eval echo $cmd)"
    eval $cmd
}

################################################################################
# Remove from end of line.  This function was made because
# when doing org-babel-tangle in emacs on Windows, even if the
# file is a UNIX file with LF opened through TRAMP, when tangling
# the resulting file has CRLF line endings.  Another way is to use
# the above function p.org-tangle on the UNIX system.  If however
# the emacs on that system is not the right version or is
# missing some packages, then it may only be possible to tangle
# it correctly on the Windows machine's emacs.  In that case
# this function can be used on the file after.
################################################################################
function p.crlf-to-lf(){
    local file=$1
    cmd="sed 's/^M$//' \"\$@\""
    printf "sed command: \033[1;32m%s\033[0m\n" "${cmd}"
    sed 's/
$//' "$@"
}


################################################################################
# Case insensitive glob find
################################################################################
function p.igfind(){
    find . -iname "*$1*"
}

function p.myprocs(){
    ps -F -u "$USER"
}

function p.tcheck(){
    local nb_tmux
    nb_tmux=$(pgrep -au "$USER" tmux | wc -l)
    local tmux_color=""
    if ((nb_tmux > 15)) ; then
        tmux_color="\033[1;31m"
    elif ((nb_tmux > 10)) ; then
        tmux_color="\033[1;33m"
    fi

    printf "${tmux_color}Number of tmux procs : %s\033[0m\n" "${nb_tmux}"
}

function p.pcheck(){
    local nb_procs
    nb_procs=$(ps -u "$USER" | wc -l)
    local proc_color=""
    if ((nb_procs > 200)) ; then
        proc_color="\033[1;31m"
    elif ((nb_procs > 150)) ; then
        proc_color="\033[1;33m"
    fi
    printf "${proc_color}Number of processes  : %s\033[0m\n" "${nb_procs}"
}

function p.check-processes(){
    p.pcheck
    p.tcheck
}

function p.unansi(){
    sed 's/\x1b\[[0-9;]*m//g' "$@"
}

function p.qsubi(){
    qsub -I -lselect=1:ncpus=80:mem=201gb "$@"
}

function p.quiet-make(){
    # Most PRN-SI projects have set(CMAKE_VERBOSE_MAKEFILE TRUE) which
    # means the makefiles verbose by default and require an explicit
    # 'VERBOSE=' (setting to nothing) to make them non-verbose
    PHIL_VERBOSE_MAKE=""
}

function p.verbose-make(){
    # Most PRN-SI projects have set(CMAKE_VERBOSE_MAKEFILE TRUE) which
    # means the makefiles verbose by default and require an explicit
    # 'VERBOSE=' (setting to nothing) to make them non-verbose
    PHIL_VERBOSE_MAKE=1
}


function make(){
    (
    set -o pipefail
    if ! on_compute_node ; then
        local arg
        for arg in "$@" ; do
            if [[ "${arg}" == -j* ]] ; then
                echo "You are on host ${HOSTNAME} ... you should not use '-j'.  Use 'command make $*' to bypass this function if you are sure"
                return 1
            fi
        done
    fi
    CLICOLOR_FORCE=yep command make VERBOSE=${PHIL_VERBOSE_MAKE} --no-print-directory "$@" 2>&1 | highlight.sh error "" warning "" "undefined \w*" "^make.*"
    )
}


function p.dusage(){
    du --max-depth=1 -h | sort -h
}

p.pgrep(){
    #  -f, --full
    #         The  pattern is normally only matched against the
    #         process name.  When -f is set, the  full  command
    #         line is used.
    #
    pgrep -u $USER -f "$@"
}

p.ps(){
    # Note, 
    ps -f -u $USER --cols $(tput cols) | sort -k 8
}
p.pst(){
    # Note, 
    ps f -f -u $USER
}

p.check_procs_pppn(){
    local pppn=${1}
    if ! echo ${pppn} | grep -P "(ppp5)|(ppp6)" &>/dev/null ; then
        echo "Argument 1 must be ppp5 or ppp6"
        return 1
    fi

    for node in ${pppn}login-001 ${pppn}login-002 ; do
        printf "\033[1;32mLogging in to $node\033[0m\n"
        ssh -t -J${pppn} ${node} 'ps -u phc001 -f'
    done
}

p.check_procs_all(){
    for pppn in ppp5 ppp6 ; do
        printf "\033[1;35mChecking nodes on ${pppn}\033[0m\n"
        p.check_procs_pppn ${pppn}
    done
}


################################################################################
# Acquire compute node for building and running GEM (or anything else)
################################################################################
function p.qsubi(){
    qsub -I -lselect=1:ncpus=72:mem=50gb "$@"
}


function vimw(){
    local cmd=$1
    if [[ -z "${cmd}" ]] ; then
        p.error "Please provide a command"
        return 1
    fi

    local cmd_path
    if ! cmd_path=$(which ${cmd}) ; then
        p.error "Command not found using which"
        return 1
    fi
    vim ${cmd_path}
}

function p.view_listing(){
    local compressed_listing=$1
    if ! [[ -f "${compressed_listing}" ]] ; then
        p.error "Listing '${compressed_listing}' does not exist"
        return 1
    fi
    # Assume that mktemp always succeeds
    local tempfile=$(mktemp uncompressed_listing_XXXXXX.sh)
    gunzip -c ${compressed_listing} > ${tempfile}
    vim ${tempfile}
    if ! rm ${tempfile} ; then
        p.error "Could not remove '${tempfile}'"
    fi
}

function vim(){
    if [[ $(hostname) == ppp* ]] ; then
        $HOME/fs1/bin/vim "$@"
    else
        /usr/bin/vim "$@"
    fi
}

function configure_vim(){
    complete -o default -F __complete_git_colon_paths vim
    alias vim='wrap_command_colon_paths vim -p'
}

#
# Because $PYTHONSTARTUP is ignored when using the '-i' option, we just
# prepend its content to the python file we are running.
#
py3i(){
    file=$1
    python3 -i -c "$(cat ~/.pyrc $file)"
}


function dump-environment-to-tmpfile(){
    local envdump_dir=$HOME/envdumps
    mkdir -p ${envdump_dir}
    local envdump_file=$(mktemp env_dump_$(TZ=America/Toronto date +%Y-%m-%d_%H:%M:%S)_XXX.txt --tmpdir=${envdump_dir})
    echo "envdump_file = ${envdump_file}" >&2
    echo "\$0 = '$0'" >> ${envdump_file}
    echo "\$@ = '$@'" >> ${envdump_file}
    command env >> ${envdump_file}
}

function reminders(){
    printf "\033[0mC-f or ^[L does shell-forward-word (.inputrc)\n" >&2
    printf "\033[0m^[l does forward-word (.inputrc)\n" >&2
    printf "\033[0mC-b or ^[H does shell-backward-word (.inputrc)\n" >&2
    printf "\033[0m^[h does backward-word (.inputrc)\n" >&2
    printf "\033[0mC-t does C-aC-fC-w (change command)\n" >&2
    printf "\033[0mC-xp does \"prepend edit PATH\"\n" >&2
}

function xargso(){
    if [[ "${1}" == "" ]] ; then
        p.error "At least one argument must be give"
        return 1
    fi
    if [[ "${1}" == -h ]] ; then
        printf "${FUNCNAME[0]} does the equivalent of 'xargs -o' on BSD"
        printf "which is to reopen STDIN as /dev/tty in the child process\n"
        printf "This is useful to when opening an interactive application\n"
        printf "like vim\n"
        return 0
    fi
    cmd="$@ \"\$@\" </dev/tty"

    print_args xargs sh -c "${cmd}"
    printf "===============================\n"
    print_args xargs sh -c "${cmd}" "$@"
    printf "===============================\n"
    xargs sh -c "${cmd}" fuckface
    # xargs sh -c "${cmd}" "$@"
    # this does not work :
    # xargs sh -c "$@ \"\$@\" </dev/tty"
    print_args xargs sh -c "$@ \"\$@\" </dev/tty"
}


function x.use(){
    local pack_dir="${1}"
    shift
    if [[ -z "${1}" ]] ; then
        p.error "An argument must be provided"
        return 1
    fi

    local pack_name="${1}"
    if ! [[ -f ${pack_dir}/${pack_name} ]] ; then
        p.error "No package named '${pack_name}' in ${pack_dir}"
        return 1
    fi

    shift
    local status
    #source ${pack_dir}/${pack_name} "$@" 
    local i=0
    while IFS= read -r line ; do
        : $((i++))
        if [[ -z "${line}" ]] ; then
            continue
        fi
        printf "\033[1m${FUNCNAME[1]}: "
        if [[ ${line} == \#* ]] ; then
            printf "\033[22;34m$(eval echo ${line})\033[0m\n"
        else
            printf "\033[1;32m$(eval echo ${line})\033[0m\n"
        fi
        if ! eval ${line} ; then
            p.error "error on line ${i} of ${pack_dir}/${pack_name}"
        fi
    done < ${pack_dir}/${pack_name}
    status=$?
    if [[ ${status} != 0 ]] ; then
        p.error "Sourcing '${pack_dir}/${pack_name}' returned an error : $?"
    fi
    return ${status}
}

function p.use(){
    x.use ${PACK_DIR} "$@"
}

function f.use(){
    x.use ~for000/.profile.d/interactive/pack "$@"
}

function __print_args(){
    # Useful to double check how arguments are given to a program.
    # For example, xargso above, the arguments get split /c
    local i=1
    echo "${FUNCNAME[1]}: \$0   = $0"
    echo "${FUNCNAME[1]}: \$#   = $#"
    echo "${FUNCNAME[1]}: args = '$@'"
    for arg in "$@" ; do
        echo "${FUNCNAME[1]}: arg[$((i++))] = $arg"
    done
}

function p.ftake(){
    if [[ -z "${1}" ]] ; then
        p.error "Argument required"
        return 1
    fi
    local to_take="$(echo ~for000/.profile.d/interactive/pack/$1)"

    if ! [[ -f ${to_take} ]] ; then
        p.error "Package to take '${1}' does not exist in '~for000/.profile.d/interactive/pack'"
        return 1
    fi

    local new_name
    if [[ -n "${2}" ]] ; then
        new_name=${2}
    else
        new_name=""
    fi

    if ! cp ${to_take} ${PACK_DIR}/${new_name} ; then
        p.error "Could not copy '${to_take}' to '${PACK_DIR}/${new_name}'"
        return 1
    fi
}

log(){
    echo "${FUNCNAME[1]}: $*" >> ~/.log.txt
}

_x.use(){
    local pack_dir=$1
    local prev cur words cword
    log "================================================================="
    _init_completion || return

    log "prev=${prev}, cur=${cur}, words=${words[@]}, cword=${cword}"
    case ${cword} in
        0) echo "Can't happen!" ;;
        1) COMPREPLY=($(compgen -W "$(cd ${pack_dir} ; command ls | command grep -v '^_')" -- ${cur})) ;;
        2|*) _dispatch_pack_complete ${prev} ;;
    esac
}

_p.use(){
    _x.use ${PACK_DIR}
}

_f.use(){
    _x.use ~for000/.profile.d/interactive/pack
}

#
# Default is not applied here because p.use's first argument cannot be a file
# from PWD (unless we are in ${PACK_DIR} but those will get suggested by _p.use
# anyway.  Instead, we use _filedir to suggest give the default suggestions.
#
complete -F _p.use p.use p.view-pack
complete -F _f.use f.use f.view-pack p.ftake
p.view-pack(){
    vim ${PACK_DIR}/${1}
}
f.view-pack(){
    vim ~for000/.profile.d/interactive/pack/${1}
}

_dispatch_pack_complete(){
    case ${1} in
        code-tools) COMPREPLY=($(compgen -W "gnu intel gnu9" -- ${cur})) ;;
        rpnpy) COMPREPLY=($(cd $HOME ; _filedir)) ;;
        *) _filedir ;;
    esac
}

function p.show-vars(){
    # Show environment variables and shell variables
    (

        local abbrev=$'\033[1;33m...\033[0m'
        GLUSTER_BARRIER_OPTIONS=${abbrev}
        GLUSTER_COMMAND_TREE=${abbrev}
        GLUSTER_FINAL_LIST=${abbrev}
        GLUSTER_GEO_REPLICATION_OPTIONS=${abbrev}
        GLUSTER_GEO_REPLICATION_SUBOPTIONS=${abbrev}
        GLUSTER_PROFILE_OPTIONS=${abbrev}
        GLUSTER_QUOTA_OPTIONS=${abbrev}
        GLUSTER_TOP_OPTIONS=${abbrev}
        GLUSTER_TOP_SUBOPTIONS1=${abbrev}
        GLUSTER_TOP_SUBOPTIONS2=${abbrev}
        GLUSTER_VOLUME_OPTIONS=${abbrev}
        LS_COLORS=${abbrev}
        _xspecs=([...]="...")
        unset abbrev

        declare -p
    )
}

function show-functions(){(
    # Show all function names with definition location
    shopt -s extdebug
    local functions
    if [[ -n ${1} ]] ; then
        functions=($(declare -F 2>&1 | cut -d ' ' -f 3 | command grep "$1"))
    else
        functions=($(declare -F 2>&1 | cut -d ' ' -f 3))
    fi

    for f in "${functions[@]}" ; do
        declare -F $f
    done | awk '{printf "%c[32m%s %c[1;35m%s %c[1;33m%s%c[0m\n", 27, $1, 27, $2, 27, $3, 27}'
)}

################################################################################
# PROBLEM: If you have 'set colored-stats on' in your ~/.inputrc, readline will
# color completion candidates according to LS_COLORS.  Therefore it will color
# anything that is not a file (program options) according to the as 'missing
# files' which if you have 'mi=01;05;37;49' in your LS_COLORS is bold blinking
# bright white on red background which is super annoying.

# SOLUTION: Since readline parses LS_COLORS at initialization and never again
# after that, the trick is to set 'mi=00' in LS_COLORS, then do anything that
# causes readline to be initialized, and then set LS_COLORS back to its
# original value.  Alternatively we could just not put anything for missing
# files in LS_COLORS but I wanted figure out a way to have some coloring for
# missing files
#
# In http://git.savannah.gnu.org/cgit/bash.git/tree/lib/readline/:
# - In parse_colors.c:300 Function _rl_parse_colors() parses LS_COLORS
# - In readline.c:1322 Function readline_initialize_everything
# - In readline.c:1183 Function rl_initialize() calls readline_initialize_everything()
#   only if rl_initialized == 0 then sets rl_initialized to 1 so that it
#   is never called again and does "other stuff".  Future calls to
#   readline_initialize_everything() only do the "other stuff"
# - In realine.c:354 Function readline(), rl_initialize() is called everytime
#   but after the first time, it only does the "other stuff".
################################################################################
set_ls_colors_for_readline_and_ls(){

    # Set LS_COLORS however you like
    eval "$(dircolors -b ~/.dir_colors.256color)"

    # Initialize readline with those same LS_COLORS except for the 'mi' part
    local my_ls_colors="${LS_COLORS}"
    LS_COLORS="$(echo "${LS_COLORS}" | sed 's/mi=[0-9;]*/mi=00/')"
    bind -f ~/.inputrc # Anything that causes initialization of readline library

    # Put back the 'mi' part in LS_COLORS
    # We need the 'show-colored-stats' to be for BASH only in ~/.inputrc since
    # the python interpreter will initialize readline in its process and will
    # read LS_COLORS.  Anyway, we don't want show-colored-stats in Python so
    # that is totally OK.
    LS_COLORS="${my_ls_colors}"

    # Another option would be to have two files but ideally, you want LS_COLORS
    # for readline to be the same for everything except for the 'mi' part
    # eval "$(dircolors -b ~/.dir_colors.readline)"
    # bind -r ~/.inputrc
    # eval "$(dircolors -b ~/.dir_colors.256color)"
}

# dump-environment
p.env(){
    env -0 | sort -z | tr '\0' '\n'
}

fix-source-complete(){
    complete -o default -o nospace -o filenames -F _DottableCompletion source .
}

fdate(){
    date +%Y-%m-%d_%H.%M.%S
}

p.mcd(){
    local dir=$1
    if [[ -z ${dir} ]] ; then
        p.error "Name required for new directory"
        return 1
    fi

    echo "mkdir ${dir}"
    mkdir ${dir} || return 1
    echo "cd ${dir}"
    cd ${dir} || return 1
}

p.cmakel(){
    cmake "$@" | less
}

p.shame(){
    trap 'echo "                      a commoner kicks you"' SIGINT
    stty -echo
    for((i=0;i<5;i++)); do
        echo -n "shame!"
        sleep 1
        echo -n " ding"
        sleep 0.5
        echo -n " ding"
        sleep 2
        echo ""
    done
    echo "y'know, like they did to Cercei Lannister"
    stty echo
    trap '' SIGINT
    exit 1
}

p.view-rev-file(){
    case "${1}" in -h|--help)
        printf "Show a file at a certain revision.  Convenience wrapper for 'git show <rev>:<file>'\n\n"
        printf "\t${FUNCNAME[0]} <rev> <file> [vim-args...]\n"
        printf "\t${FUNCNAME[0]} <rev>:<file>:<line>\n\n"
        printf "The one argument form is meant to take the output\n"
        printf "of a 'git grep -p <pattern> <rev>' command\n"
        return
        ;;
    esac

    if [[ "$1" == *:* ]] ; then
        local rev=${1%%:*}
        local file_line_col=${1#*:}
        local file=${file_line_col%%:*}
        local line_col=${file_line_col#*:}
        local line=${line_col%%:*}
        echo "ref=${rev}, file_line_col=${file_line_col}, file=${file}, line=${line}"
        git show ${rev}:${file} | vim -R - -c "doautocmd BufRead ${file}" +${line}
    elif (( $# >= 2 )) ; then
        local rev=$1
        local file=$2
        shift; shift
        local ft=${file##*.}
        case ${file} in
            *Makefile|*makefile) ft=make ;;
            CMakeLists.txt) ft=cmake ;;
        esac

        git show ${rev}:${file} | vim -R - -c "doautocmd BufRead ${file}" "$@"
    else
        p.error "Incorrect arguments"
        ${FUNCNAME[0]} --help
        return 1
    fi
}

p.log(){
echo "${FUNCNAME[1]}(): $@" >> ~/.log.txt
}
source $HOME/.philconfig/shell_lib/file_complete_elsewhere.bash
_p.view-rev-file(){
    local cur prev words cword
    _init_completion || return

    echo "${FUNCNAME[0]}: cword = ${cword}" >> ~/.log.txt
    if (( cword == 1 )) ; then
        if ! complete -p git 1>/dev/null 2>/dev/null ; then
            __load_completion git
        fi
        #
        # Git completion is set with 'compopt -o nospace' and
        # the functions add spaces to the COMPREPLY candidates
        #
        compopt -o nospace
        compopt -o filenames
        __git_complete_refs
        if (( ${#COMPREPLY[@]} == 1 )) ; then
            compopt +o filenames
        fi
    else
        local git_repo
        if ! git_repo=$(git rev-parse --show-toplevel 2>/dev/null) ; then
            return
        fi
        file-complete-elsewhere ${git_repo}

        # compopt -o nospace
        # compopt -o filenames

        # COMPREPLY=( $(cd ${git_repo} ; compgen -f -- "${cur}") )
        # if (( ${#COMPREPLY[@]} == 1 )) ; then
        #     only_candidate=${COMPREPLY[0]}
        #     if [[ -f ${git_repo}/${only_candidate} ]] ; then
        #         COMPREPLY[0]="${only_candidate} "
        #         compopt +o filenames
        #     elif [[ -d ${git_repo}/${only_candidate} ]] ; then
        #         COMPREPLY[0]="${only_candidate}/"
        #     fi
        # fi
    fi
    p.log "COMPREPLY=${COMPREPLY[@]}"
    # for c in "${COMPREPLY[@]}" ; do
    #     p.log "COMPREPLY elem : '${c}'"
    # done
}
alias nn='vim ~/nemo_xios_notes.org'

# When using r.load, the output of the underlying `ssmuse-sh` command is hidden
# by default.  Since it was requested that it be shown, a variable LOG_LEVEL
# was added which if set to 'ERROR' would not redirect the output of
# `r.shortcut-2.dot` to /dev/null
_set_rload_log_level(){
    export LOG_LEVEL=ERROR
}


# List all paths that ld will search in for libraries in the current environment
p.get_ld_search_paths(){
    # ldconfig -v outputs a path followed by all shared libraries in that path
    # with a leading tab.  To get just the paths, we filter out the lines
    # beginning with a tab.
    ldconfig -v 2>/dev/null | grep -v ^$'\t'
}

p.set-title(){
    # TMUX intercepts this and stores it in #T.  Then TMUX may
    # output something for the terminal program.  To have TMUX
    # "pass it through", use
    #     set-option -g set-titles on
    #     set-option -g set-titles-string "#T"
    printf "\033]0;$*\007"
}
p.get-cursor(){
    # https://stackoverflow.com/questions/2575037/how-to-get-the-cursor-position-in-bash
    local CURPOS
    echo -en "\E[6n"
    read -sdR CURPOS
    echo ${CURPOS#*[}
}

#
# Lifted from /usr/share/bash-completion/completions/make
#
p.get-make-targets(){
    words=("$@")
    # before we check for makefiles, see if a path was specified
    # with -C/--directory
    local -a makef_dir
    for (( i=0; i < ${#words[@]}; i++ )); do
        if [[ ${words[i]} == -@(C|-directory) ]]; then
            # eval for tilde expansion
            eval makef_dir=( -C "${words[i+1]}" )
            break
        fi
    done

    # before we scan for targets, see if a Makefile name was
    # specified with -f/--file/--makefile
    local -a makef
    for (( i=0; i < ${#words[@]}; i++ )); do
        if [[ ${words[i]} == -@(f|-?(make)file) ]]; then
            # eval for tilde expansion
            eval makef=( -f "${words[i+1]}" )
            break
        fi
    done

    if [[ "$(type -t _make)" != function ]] ; then
        _completion_loader make
    fi

    #
    # shopt -po <opt> prints a command to set <opt> to its current value
    #
    local reset=$(shopt -po posix)

    #
    # 'make -npq' prints all info from parsing the makefile with potential
    # '-f somefile' or '-C somedir'.  This output is passed through a sed
    # command with sed script produced by _make_target_extract_script which
    # filters out everything except target names.
    #
    set +o posix
    LC_ALL=C make -npq __BASH_MAKE_COMPLETION__=1 "${makef_dir[@]}" "${makef[@]}" .DEFAULT 2>/dev/null \
        | command sed -nf <(_make_target_extract_script -- "${cur}") \
        | sort
    $reset
}

complete -o bashdefault -o default -o nospace -F _p.view-rev-file p.view-rev-file


alias git=git-enforce-rules-of-philippes
p.profile.main
unset -f p.profile.main
unset -f p.profile.main_interactive
