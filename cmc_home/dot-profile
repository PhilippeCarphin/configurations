#!/bin/bash

p.error(){
    printf "${FUNCNAME[1]}: \033[1;31mERROR\033[0m: $*\n" >&2
}

function p.profile.main(){
    export LOG_LEVEL=ERROR # For r.load
    export CMAKE_EXPORT_COMPILE_COMMANDS=TRUE
    export TZ=America/Toronto
    export LANG=en_US.UTF-8
    export SSM_DEV=/home/ords/cmdd/cmds/nil000/ssm
    export GITLAB_RUNNER_SCIENCE_ORDSOUMET_KEEP_FILES='yas'
    export GONOSUMDB=gitlab.science.gc.ca
    export PATH="$HOME/bin:$HOME/.local/bin${PATH:+:$PATH}:$HOME/tools/go/bin"
    export GITLAB_ACCESS_TOKEN="$(cat ~/.ssh/gitlab-access-token)"
    export EDITOR=/usr/bin/vim
    source $HOME/.cargo/env
    . ssmuse-sh -x /fs/ssm/hpco/exp/ssmuse/ssmuse-1.13-beta2
    configure_fs1_env
    configure_spack
    configure_vscode_server_environment
    if [[ "$-" == *i* ]] ; then
        p.profile.main_interactive
    fi
}

function p.profile.main_interactive(){
    export PYTHONSTARTUP=~/.pyrc
    export PACK_DIR=${HOME}/.profile.d/interactive/pack
    set_ls_colors_for_readline_and_ls

    source "$HOME/Repositories/github.com/philippecarphin/bash-powerline/powerline.sh"
    PROMPT_COMMAND="$PROMPT_COMMAND; history -a"
    source "$HOME/.git-completion.bash"
    source "$HOME/.ssh/ssh_functions.sh"
    source "$HOME/.philconfig/shell_lib/x.use"
    source "$HOME/.philconfig/shell_lib/functions.sh"
    source "$HOME/.philconfig/shell_lib/view-rev-file.sh"
    FZF_COMPLETION_OPT="--preview 'bat --color=always {}'"
    source ~/.fzf.bash
    _source_dir "$HOME/.bash_completion.d"

    alias ls='ls --color -h'
    alias grep='grep -n --color'
    alias tree='tree -C'
    alias rmb='rm -rf ../build/*'
    alias rg='rg --no-heading --color=auto'
    alias gdb='~phb001/.local_rhel-8-icelake-64/bin/gdb -q -tui'
    alias gdbserver='~phb001/.local_rhel-8-icelake-64/bin/gdbserver'
    alias diff='diff -u --color'
    alias :wqa='exit 0'
    alias :q='exit 0'
    alias :qa='exit 0'
    alias :wq='exit 0'
    alias :cq='exit 1'
    alias cd='wrap_command_colon_paths cd'
    complete -F __complete_git_colon_dirs cd
    alias git=git-enforce-rules-of-philippes
    complete -o default -o nospace -o filenames -F _DottableCompletion source .
    shopt -s direxpand # Merci Philippe Blain :D
    check-alert-file ~sici000/alert
    check-alert-file ~/alert
    maybe_cd_to_pbs_o_workdir
    configure_history
    configure_vim
}

configure_fs1_env(){
    # See code of __load_completion from /usr/share/bash-completion/bash_completion ...
    # It searches an array of directories that starts out as
    # Since I don't define BASH_COMPLETION_USER_DIR and XDG_DATA_HOME
    # is also not defined, dirs=(${HOME}/.local/share/bash-completion/completions).
    # After that it does
    #     dirs=(${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions)
    #     for dir in ${XDG_DATA_DIRS:-/usr/local/share:/usr/share};
    #         dirs+=($dir/bash-completion/completions);
    #     done
    # then for each of
    #
    export STOW_DIR="$HOME/fs1"
    XDG_DATA_DIRS=${XDG_DATA_DIRS:+${XDG_DATA_DIRS}:}${STOW_DIR}/etc
    export PACKAGE_DIR="$STOW_DIR/Cellar"
    export LD_LIBRARY_PATH="${STOW_DIR}/lib:${STOW_DIR}/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}"
    export PATH=${STOW_DIR}/bin${PATH:+:${PATH}}
    _source_dir "$HOME/fs1/etc/bash_completion.d"
    _source_dir "$HOME/fs1/etc/profile.d"
}

maybe_cd_to_pbs_o_workdir(){
    if [[ "${PBS_ENVIRONMENT}" == PBS_INTERACTIVE ]] ; then
        printf "PBS_ENVIRONMENT detected, cd'ing to \$PBS_O_WORKDIR=${PBS_O_WORKDIR}\n" >&2
        if ! cd "${PBS_O_WORKDIR}" ; then
            p.error "Could not CD to '$PBS_O_WORKDIR', perhaps it is not on a network filesystem"
        fi
        echo "${PBS_JOBID}" > ~/.ssh/current_job
        echo "JOBID ${PBS_JOBID} written in ~/.ssh/current_job" >&2
    fi
}


function maybe-source(){
    if [ -f "${1}" ] ; then
        source "$1"
    fi
}

configure_vscode_server_environment(){
    if [[ -v VSCODE_AGENT_FOLDER ]] ; then
        export GO111MODULES=off
        export TMPDIR=/tmp/$USER/vscode-server
        mkdir -p ${TMPDIR}
    fi
}

configure_spack(){
    export SPACK_SKIP_MODULES=y
    if [[ -n "${SPACK_SKIP_MODULES}" ]] ; then echo "WARNING: SPACK_SKIP_MODULES is set" >&2 ; fi
    . $(repos -get-dir spack)/share/spack/setup-env.sh
}

function check-alert-file(){
    local alert_file="$1"
    if [ -e "${alert_file}" ] ; then
        printf "\033[1;31m Alert from %s\n" "${alert_file}" >&2
        cat "${alert_file}"
    fi
}

function configure_history(){
    # https://stackoverflow.com/a/19533853/5795941
    # Other contexts may truncate the history, namely some people have said that
    # history may get truncated at bash startup before these two settings have
    # taken effect.  Therefore, we set the history to unlimited size, and only
    # after doing that we set the history file to a different file.
    HISTSIZE=-1
    HISTFILESIZE=-1
    HISTIGNORE="rm -rf *"
    HISTFILE=~/.eternal_bash_history
    HISTTIMEFORMAT=$'\033[1;32m%Y-%m-%d \033[1;33m%H:%M:%S\033[0m \033[1;31m'
}


function _source_dir(){
    local dir="$1"
    if ! [ -d "$1" ] ; then
        return 1
    fi
    local f
    for f in $(command env -i ls $dir) ; do
        if ! ( [[ "$f" = *.sh ]] || [[ "$f" = *.bash ]] ) ; then
            continue
        fi
        if ! source "$dir/$f" ; then
            p.error "sourcing '$dir/$f' returned non-zero"
        fi
    done
}

function configure_vim(){
    complete -o default -F __complete_git_colon_paths vim
    function vim()(
        if [[ $(hostname) != ppp* ]] ; then
            /usr/bin/vim -p "$@"
            return
        fi
        local IFS=:
        for d in ${CMAKE_PREFIX_PATH} ; do
            C_INCLUDE_PATH=${d}/include${C_INCLUDE_PATH:+:${C_INCLUDE_PATH}}
        done
        while IFS='=' read -r -d $'\0' k v ; do
            if [[ "${k}" = *_DIR ]] ; then
                C_INCLUDE_PATH=${v}/include${C_INCLUDE_PATH:+:${C_INCLUDE_PATH}}
            fi
        done < <(env -0)
        export C_INCLUDE_PATH
        # echo "C_INCLUDE_PATH=${C_INCLUDE_PATH}"
        wrap_command_colon_paths command vim -p "$@"
    )
}


################################################################################
# PROBLEM: If you have 'set colored-stats on' in your ~/.inputrc, readline will
# color completion candidates according to LS_COLORS.  Therefore it will color
# anything that is not a file (program options) according to the as 'missing
# files' which if you have 'mi=01;05;37;49' in your LS_COLORS is bold blinking
# bright white on red background which is super annoying.

# SOLUTION: Since readline parses LS_COLORS at initialization and never again
# after that, the trick is to set 'mi=00' in LS_COLORS, then do anything that
# causes readline to be initialized, and then set LS_COLORS back to its
# original value.  Alternatively we could just not put anything for missing
# files in LS_COLORS but I wanted figure out a way to have some coloring for
# missing files
#
# In http://git.savannah.gnu.org/cgit/bash.git/tree/lib/readline/:
# - In parse_colors.c:300 Function _rl_parse_colors() parses LS_COLORS
# - In readline.c:1322 Function readline_initialize_everything
# - In readline.c:1183 Function rl_initialize() calls readline_initialize_everything()
#   only if rl_initialized == 0 then sets rl_initialized to 1 so that it
#   is never called again and does "other stuff".  Future calls to
#   readline_initialize_everything() only do the "other stuff"
# - In realine.c:354 Function readline(), rl_initialize() is called everytime
#   but after the first time, it only does the "other stuff".
#
# IMPORTANT: This needs to be done before anything else causes the otherwise
# the initialization will already have happened with whatever LS_COLORS was at
# that time.  For example, fzf initialization does many 'bind x y' commands
# which initializes readline
################################################################################
set_ls_colors_for_readline_and_ls(){

    # Set LS_COLORS however you like
    eval "$(dircolors -b ~/.dir_colors.256color)"

    # Initialize readline with those same LS_COLORS except for the 'mi' part
    local my_ls_colors="${LS_COLORS}"
    LS_COLORS="$(echo "${LS_COLORS}" | sed 's/mi=[0-9;]*/mi=00/')"
    bind -f ~/.inputrc # Anything that causes initialization of readline library

    # Put back the 'mi' part in LS_COLORS
    # We need the 'show-colored-stats' to be for BASH only in ~/.inputrc since
    # the python interpreter will initialize readline in its process and will
    # read LS_COLORS.  Anyway, we don't want show-colored-stats in Python so
    # that is totally OK.
    LS_COLORS="${my_ls_colors}"
}


function print_array(){
    local color=true
    if [[ ${1} == --no-color ]] ; then
        color=false
        shift
    fi
    local -n  array_ref=$1
    local     array_name=$1
    local -ri nb_items=${2-${#array_ref[@]}}
    printf "Uncolored quotes are not part of the array element\n"
    printf "%s\n" "If array elment contains true ($'\033[31m' as opposed to '\033[31m')"
    printf "color codes, then colors will be weird\n"
    local fmt="\033[35m%s\033[0m[\033[36m%d\033[0m]='\033[32m%s\033[0m'\n"
    if ! ${color} ; then
        fmt="%s[%d]='%s'\n"
    fi
    for((i=0;i<nb_items;i++)) ; do
        printf "${fmt}" "${array_name}" "$i" "${array_ref[i]}"
    done
}

# Some functions like 'trap -p SIG' print their output in such a way that it
# can be manually copy-pasted into a shell to set the same trap:
# $ set_trap="$(trap -p exit)"
# $ trap '' exit
# $ eval "${set_trap}"
# If we want to get the actual code of the trap, we need to get the 3rd argument
# of the command stored in ${set_trap} which can be done with
# $ exit_trap="$(eval echo-nth-arg 3 "$(trap -p EXIT)")"
# An eval is required because the output of trap is meant to be run as if it
# was typed so that the code of the trap becomes exactly one argument.
function echo-nth-arg(){
    local n=$1
    shift
    echo "${!n}"
}

function shell_vars(){
    local all_vars=$(mktemp all_vars.XXXXXX)
    compgen -v | sort >${all_vars}
    local env_vars=$(mktemp env_vars.XXXXXX)
    compgen -e | sort >${env_vars}
    # BEGIN RANT
    # Very important note: -1 tells comm to SUPPRESS column 1 not to show it
    # Every time I use comm (which is not super often) I glance at the manpage
    # and see 
    # -1 ... (lines unique to file 1)
    # -2 ... (lines unique to file 2)
    # and the "unique to file 1" draws my eye and I look no further.  I know it
    # clearly says "suppress" but when writing this function and the previous
    # time I had to use comm, both times I missed it and went "unique to file 1,
    # that's what I want, comm -1 ..., why isn't it doing what I want?!"
    # END RANT
    comm -23 ${all_vars} ${env_vars}
    rm "${all_vars}" "${env_vars}"
}

function func_change(){
    local initial_funcs=$(mktemp -t initial_funcs.XXXXXX)
    compgen -A function | sort >${initial_funcs}
    local final_funcs=$(mktemp -t final_funcs.XXXXXX)
    (
        "${@}"
        compgen -A function | sort >${final_funcs}
    )
    printf "\033[1;32mNew functions:\033[0m\n"
    printf "\033[1;32m==============\033[0m\n"
    comm -23 ${final_funcs} ${initial_funcs}
    printf "\033[1;31mRemoved functions:\033[0m\n"
    printf "\033[1;31m==================\033[0m\n"
    comm -13 ${final_funcs} ${initial_funcs}
    printf "\033[1;33mKept functions\033[0m\n"
    printf "\033[1;33m==============\033[0m\n"
    comm -12 ${final_funcs} ${initial_funcs}
    rm "${final_funcs}" "${initial_funcs}"
}

function func_change_2(){
    local initial_funcs=$(mktemp -t initial_funcs.XXXXXX)
    declare -f >${initial_funcs}
    local final_funcs=$(mktemp -t final_funcs.XXXXXX)
    (
        "${@}"
        declare -f >${final_funcs}
    )
    python3 ~/A_CLASSER/diff_functions.py -i ${initial_funcs} -f ${final_funcs}
    rm "${final_funcs}" "${initial_funcs}"
}


###################### KEEP THIS AT THE END ####################################
p.profile.main
unset -f p.profile.main
unset -f p.profile.main_interactive
